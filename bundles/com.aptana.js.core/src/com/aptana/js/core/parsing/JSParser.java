package com.aptana.js.core.parsing;

import com.aptana.parsing.IRecoveryStrategy;
import com.aptana.parsing.ast.IParseNode;
import com.aptana.core.build.IProblem;
import com.aptana.js.core.JSCorePlugin;
import com.aptana.parsing.WorkingParseResult;
import com.aptana.js.core.preferences.IPreferenceConstants;
import java.io.IOException;
import com.aptana.parsing.ast.ParseError;
import java.util.ArrayList;
import java.util.List;
import com.aptana.parsing.IParser;
import com.aptana.parsing.ParseResult;
import org.eclipse.core.runtime.Platform;
import com.aptana.js.core.IJSConstants;
import com.aptana.parsing.IParseState;
import beaver.*;
import com.aptana.js.core.parsing.ast.*;
import com.aptana.parsing.util.ParseUtil;
import com.aptana.parsing.ast.IParseError;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "JS.grammar".
 */
@SuppressWarnings({ "unchecked", "rawtypes" })
public class JSParser extends Parser implements IParser {
	static public class AltGoals {
		static public final short Script = 111;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjNGUSKqKJdzbSBaUJJxeK0O6ZDxc21mSsi7Vi2dPfAc03mO8K6sBlYYWAXufIfOlqta5" +
		"wauuY8CM2lFt#ks$JaxiBbmk7vkKtRxRCpixCpixRVIzv8MhwAksWM$aiVeVVftPq5zr8Dz" +
		"CjT1lTJdVGdVmMFKzzw00Tf2$eIr5Rr1TrHR8uLwIAfdGltKttS3gdqM7QJeVeTreeqiHve" +
		"fQeAUg83D5OL1TLHJtHHDGGAKpKd5hBKJoOMj4$KefgqXBdq5JgHj$IBzILNPp8ILo8UjC4" +
		"#eE#fcze17r7asWo$K3Jw4SnKKoWxlICzQAuXfwb9xcvk8IQy5fgGUVHnTIIpgSKQaoPiT6" +
		"6QYXjh9TiRVXZKOrVX3OpU01Lvm5YV0YzdWgj5zNcL$XIleoU3gKDl#tc8vg9vlmUlnkMpo" +
		"AgH4Mf41MXOdG65QV$qPbKWafIAIfDPQWibQEpQ3Nz17xrw3xmMyqNKqM#XyfpAsifLQ32O" +
		"X8jvpPSXUhGurI5Td4HIgRTyX0ju07iu39SbgkBQxaawkTpEQfAZz4J$07Lf$lfGNg4#ehb" +
		"l91wSWcgmu96eUs9V9H#YbTwlbP9p#L40oKzNy$xQ35ogtYVQ0rPBk1PHlgvrfTSakVpDP2" +
		"#3d0zZA97UgeZ6d46b#2MB7WnjwSJLd$bItGJjUN2EVaIBwMHD9P#fIdq6#qFvKjqDe$aSJ" +
		"oSbd1L$e7Mq0RQmatuGcugTb0Zs3IPlkUQT0EruNNmezOHUD2ZucUndRkAfM8PTn4BmQcdF" +
		"CHhnKuQ9MPPGwaHty2t0OzHtCLiiPWQqanoS7AkUyZbwCYrF5Wq40rfji$eVAj61zPT1PXf" +
		"zOcHJH4jU0nFfpcmR1s72pPTogrbQJ5Tp33zFnsY$uT0CKsiX6Sayt9h90cQnvluR$63c4f" +
		"rh9kLJQslODENOwC5pwOQefWe8peeBU2psZDuEwqKv$DJmHx2juGPltMYgtY6Vz4ylkUrrW" +
		"inah#8k1Xp31yU8BVIUbud#d1hyG7as0H9Ud4lHCiF8l3q7hGPuxWsHZwqJcI9KMAjifgL9" +
		"JVpEhuevBmCSyMIUxaUhbLxnQ$Y3xwCfz4##fD7nKfwMPf#vbI#JwxXGzPmkGosdmVfQs0U" +
		"Mk9y#D5sK2X$k1$neYezn#t5wzdD33w795MDbVISu22nMLmif5ngPV50sBvqH35nDFUHBgx" +
		"05RaIL#Ppk3utv4Ona$vSRi7dSNDknYqWVIQaFpyYwPV1qoxXo$bAleFRSLk#cpiY8iLA#Y" +
		"VW4VZ0wdrbLNwEryd4YAJVXfOlywjSMWwLNoBzEN$1NyPC#c7MH$mrVyFVyIZO$dlOVa94q" +
		"k$aIJo5f$5Cdi5pU24#ytX1pAHVmQjuDQ#nnbYGtlgErrdVX9AUYuLP9L$3EtWNx#Qz$2lc" +
		"zc4#AXmYCLRIKx98WjzqjCRI9jZ#4bolrk6g#ulSBHg9O$8dFeFF2p4IVuU9dol1ps5z6hE" +
		"8kLmkuMlbOhwMoq7wSeYO5yBszcxYvk2UnU$YKj6INm3Kv1Pq8Lr6br06NK5NqxNUddajNy" +
		"5NYmluQhg6hgCBg1bTHDVJvPHEvzAbT2KrfQleBxMRmDePkmavacfH6jPFgU9oSH1hyw5o5" +
		"VVdVxIMGROJXKFRZd$3Rg95qDueh2xKW3yI2Q8Y$odAYSV2wZ9UhIJ5HtnTU5t45NfdDDdU" +
		"6LcJA4sqWIxNYKFYHluGsZIJ6QA5U52K4YMplTuC5k$nLV8ysLIcKnEP5cgV5mEVI1MFo1J" +
		"PH9uh6yj6iY5YOOD8eWbNa$L59#k8h6Ojj#POCwoPihhe6RCLJ2$nhBLBzBPsYlxYHV4oF7" +
		"f0HDAdM3l4c#9jyPcrtTfgRH93n3phvrX9Rst3kckpjSNQQFMr#eava7ukLeyBn7ohgzLPB" +
		"BAwMq#AtTRZOaK46ls6#HZrVGzFTEzBVVRKZwbzZ$MerKtiuIfYavj27hAU4cF8PImOOYvQ" +
		"FSGIdtrfcBdeGn5#BdwdvgAO9$PHAtvO$8Av#1UbMkFjlgsU8KQllZZEAnm9b429v5IpdGY" +
		"ptVTe0WYAA#5qGUjbeeNTK6u9gmiXMf3rEeZ2nqXz$qWpQiNTS4OhIWrnPHmKPYn37I5qYR" +
		"vts5s9$T3IunqeKBjYVN0LmAT#SYtmsJzdKGNn6ytFBbOQFaFpItRDFQpi0SS2e#zUr6PHJ" +
		"oJd0sgPsaQw5TRcwbw4ZXGsdv$oGVO6H0xdoSYkQxCqoetTz#J3dPGL9sLt4sDehf$i8UUb" +
		"tv6764C#yrAVmypBi15vH90cCPsNkR9n8u#DrVsvc$X6r9vjspW$vE8seUNYyle#PhPZpur" +
		"F#TW77y7hrY$3hrk3npvxNSIdecBskeWNF9BaNHSIt#AKOrJGHq7pur3#SXVtAGZ#mWzcvo" +
		"$XrtEH#Gjtq7rruixPwSAJ8$KNVY3Yk3SwX6k5qYNNQssQdeUTUz0XTyNUKyNCw6ehdXFzH" +
		"0$nW7WuUst5ZvwKUZuG6uiNi5wuRXxkMXM0cCONH33tCDxSig2DGC7lfO2CSqJN1rwI3$lz" +
		"t$FLEnU1Vl#$oM$YlSHxERrw2Rjo#4$safkrGMnqYOz#l9TuB$5U$9voFHh9#axSmhN5pU9" +
		"MSPjQtuaxHLlHJgtln3tYNd6Vk9zMYuU8tCz8n1CXxeTKmpxnIN6xk4FS9UuMtMrABFA2AS" +
		"FN#1yXxaE8TBrkxCITMTqxpzLz2A7MqsdYSNLFHRXNdZsfSaJtKzGHzfvAE5suXrlQaFTKZ" +
		"d1t8ysJkTPbFOM#1vVlkkGmBau$YjpfSgA0wkA2drmPcIuEfiZlyVybhlBuX$iurVT6RRib" +
		"XVXUnsKvsIt0ildsR4GKfU3ZLDlDFf8AnbZbxEDv72l$urJFrvTYv7UbS#TtaLvvnKqvNdb" +
		"pVgwomdlbFHNzYuudtp#jYaB$dK##VwuHXVwxvQ7$iL7elsyU#fyQXVvVpKF$nwBG$pjvwF" +
		"zu5Fh$C0$zovpwTw#xmyT7CIWFyxzGxlJFBZgBB$BG$nbHw7zu7lel4ON#H#IX$x9vw1#xB" +
		"htp6fs7$YlarB$QTObqlUkorwezpNS$r1vCVME9nFS#Ep#rWtsHNj8xMDiwwdIEJaQwwteB" +
		"C9JUTZX8pRHEW0OqZBAe7$Md5#XbUeLUfO7q6hrERz2Rz0wzI#$H#zI1Fg0FwIFwc3wXGVG" +
		"f3QRFw7CQGWEeftZ58tdm4IIvzt0aHYAviDoIu#o#HkTLyZUCvExlC#7WMqD87i5l4dHRxt" +
		"SKY2slpQCeUV6Jipb5kBOKHQ8k#Ll1DWyfUGJV7WwqkJWpFsnkk4HHSj4#IFBo#Ifvq66z4" +
		"KrloGS$7nnrctS9ilad#IBvL#5iJj6TeKEZBlddKRVvqq4s$oO$R6wuH5FovuCa7vUlakVa" +
		"BJcjMezuxoc7f79BlZPgtd9rr6t#Vg3DzN4wUCkmqrRoaQUjv9CBlEGri$sbI46MlEvfA$a" +
		"3fwtaxKzRoJkUjf9tFcqbV$YqbRpBQIlvLwUjvEDFfUIHFidZsX4yoQlZIUR5FXFpOX#k5L" +
		"lxqAeSlpySgSLhH9tZLr7dE3P7hyZksq1dHl9j8EiG7$3pdcnsNxmkWlNJHWfpHFwhSPuQT" +
		"GiVYph7ur7dAAFDKUJyRVn8EPuHTOubeiwnRDGvLYZuCKGy5SiO8WRcybUSeMF8aTozPy0Q" +
		"xOqXqPC#H8Jguqds0aIlf$2nTRYuFehZaStTCN53jFKHLuUyLXJdelapHl9Nlx4gpfy4Zfz" +
		"KttSS5yNUjuRmsMFXV5QkYsBFqUCK$7OFPmwpRfp1mwDgoO9ecspMF9wvT3Ja$UWzqVLnNf" +
		"Rj#cjWD6DsVaPGdvWTnNxYCiT6vX2nud$XOuLS$T#sLbpc67bbd5ESKvnJd5FCED7nWYTJd" +
		"5ESKvnJd5ESKvnJdDDfmIdKqrflolsqrl$8tRSblKzhlQcXcYAofzb3$RZdfatk$oybcF94" +
		"RYb5kBiEmPHdvPOoxFS3WdcsoZNbnxcc$3hNb6DpJNau36LsJsHEjawz0u64Ub#hfh96XtZ" +
		"2i5ev4PVoFAqnxtdrlW5RB41Tzhtq05Lbzs#7n7BkuvunzXkmFUz0sAQUrl1MztjUUGjljj" +
		"#0BIvIpujGf$#lIjUL59LmBiTlwgQ1ttGWBi7tib3wqGaZNOYtUWVCH9kkJzZtLMpCwHqFu" +
		"a$kmQLehKhB0nvRQVq4Q$ryT1MPl9Lxodqw$pDlG4aLfFIpTbwlsnpDzWxowvgo3JJpl7rN" +
		"2BSiRblndLnIIGXRgT8XmG68cRihMuc$UPiWVaQD04eFyW0b5Vz1ixWdRuHcRNYz$lLN8qz" +
		"JrUzZ$BX##svtVat9nFeNHU3XrbvhnWsKPjmFNDPJ8y$x3Znok#q8BahADxHzs9R4uR3jWx" +
		"gLMX9bn$L6oZRyeAvxX7UgEjjsRfdCMxNR0BjxykdHVcimBDR8ymO6jymzn5RVCeVW3loei" +
		"Qj7Ih6LUwjVjl7p#l$3$X6lAR$bxk9TRWDFwAtxqD$7vzlDM6Xitc9yDZ#B4jj$IK1o$ipj" +
		"tKY$nFUANIQz3j3QfWa#n9PGfS4ql1RuG5YARRdWii7WDSHGsq49vAH4Sb4I5QB2L8IAPlE" +
		"CkZnLe8fKYSwcobI5gj8vL8sgKmrAffguBjQcEbGNCQ4#hbSDCHwDwLngGkcKIccKGKtfF9" +
		"pLR$VLB#sxu4hRZHwbn#XnUeAUfExKWvx2DRONFKtFqBFq7FNMrzI#k6u#JAj9$Tgg2tYjH" +
		"yIv7tD9pIJr$eDxTVu1n8tOQ3DAQqD6c#dGPZgqcKfp4E7dq8O8zEf7csaR$Kn7GseJ2H#r" +
		"Ab1h3xKo6E2tDdYBtlQi3zpyYljy$oj3hvQKTRDekBPkCjBJgHdIcJGQ6esbSVGzoYRGH9H" +
		"Dneeg7IkgtsYbp$V9ca83flceMGZhDwCb#IXz1n$f9shffr1BBVr4MWRffw3lPRGEieocjK" +
		"RwjTG9jLjekPP#2oX6#KYVZlGXIBy0qcTY59UeoHeJNvgjFRePUiZKTceEFufaPlIZNRGR7" +
		"DGv0wlTPf0xK$kI4xxK2PoK3frWCyNf7rn3iq3nI3wCJYPyG8r2Yi$efEZHITSw3e#PJLMq" +
		"IC6dE7fDfvsmASEcoRGFwxFi#a#duteycW5Ic67FT60d9r8wsszcoT1lMucD5Xdmq1JzITS" +
		"VspEc8lOKXuVcVlowQ1vtQnuCBM8b$tH4ib7wCmU#aGpvKo1$Yl667$HdPKH#cApbZzKLIr" +
		"ajGrij0$8t1tKayp8JjEgJhECxWrUd64gVR3xAxhRq7I7zACXp1BrCnIVTV5IKtu2HICvMB" +
		"dikn4hwJFGr6zwZ9C$GdZygmfZO7l6ETGJ80BPJiP8#0xpwung#JlVU7z9dH2XzCgXjoOjh" +
		"7no5KOgTxPlfZvgb6R1YSq1aqgUZHJfapjJZ66lRPw2ETQHGzejqrlRJQnzbzp$e85OqRS5" +
		"bMSoaTtki7NbIJCIC9DAxEIZBAqtKVrJ7IlfcwA#PlcOfp#a2wRj0UkK5wlzlCsaLva8ayT" +
		"Fc5Jk$pyJwKC4KI3$5pDhmFIjRBuULbwDDyR0zjwFjj4D3#9x$rhi9Dhi99teUfA#JQltK2" +
		"TmxG0gbPIHUt1Oo1UucmklI4dge5LiQQ3B3wZ9IjnTe7rwN$bgN5ADBYl6137OXtG7QfEAZ" +
		"vcOQhSbsL9lgtMAg$hG5d9fzNYhwIVNvD0T45arIWpwrOXXDaeq6hDS2aKQJVdgiKZGNzKd" +
		"16Y8rPjAdwdi6gURzX2jC9A#27Owzikc8pmf0vuWqQfSF#vwH7exUVKz7lUzHCYPZtzFPGz" +
		"4P9GAxql0MxAZtekvzQJWBUYd2Mp1DpqLb9JKNayrST8zUnn1ziuvgdLcmWnCKbPIKA7qEQ" +
		"Wl8TLm1RLDADYt3nXL51SW0XDK5TT15ypbFKpO7HE3BCiGHKfUeUuVfwmM0npkGXdUOck60" +
		"LNvoZVRnemdQZoPdD#DCgyNv9Rlc7bRs09kEDbZ116AS9mESfhIBFhStzo8GAV9FTce9lba" +
		"d8xjEJz3dKsHtoZmPktkao57sWBPvY36#yrAV8voNr2zGazZEozpOsFPQFIzDtpx#aGzosL" +
		"uRB9UvZrd0npx4U4QqReti#W9gs2W7NKPw9CcpBYXT0yWnAXH4FmxjBzI#8FYBUuxbhx$G4" +
		"Cr$A0sBhh$GqdoBUp5PQuUG9VDKUEgfqPPsUbBg#K2izcR$dbuAH4oBRExHWd$L2Fo7nZd2" +
		"wyE2$DZlnxqptakybtWlyLxYlSHxYVSIx#NVjIhrI3uer7DVr7zbljN$BNrdKw8ic39iJS3" +
		"gC9JsdZiLj3MovoBqfxgdGZCDxouqBzAx4k7lgOJJnKVQKBgCf356cl6HwH9y3ox$TSbXN4" +
		"RwKPpskdZlk#NVipVCEx$xRc5rYU7#qipluI5cxLyvsIt0il$9PoC5Ownozl6yZLL0wm8mN" +
		"$$TVfUBfws#Lzvu$$7#u$t$c$hddE9ZBFJFBZh7#pyr$UjTL#3EA$hz3r5x6RsFqMjLzNqu" +
		"hRKJW3u2#lVPmHhhp7Jll2BTTQdhjVxER1OrGoeJeFw1#0Awa2wYYwaLjQPBw5AwZ2wdA#X" +
		"AkegkfcleMhgEhjV$s7WZtQH$JtohvnV5RAyMtD#y2hYQ1qdkKxSt4icPt9BZtCnmY9BaRY" +
		"bqhaEmv16lnppVKK0wnMlpA4ekJixcaQujOsFpK98NF9iRBgUnv26yeNZSM#8pzDzYSxUVd" +
		"xwIv#GjEQvQawNCRcthkVedHyrRckQ$pNN#jFIMkEHnoRF$fKXSyhZaSSdZaiSbZql#BvSy" +
		"Nv$aULAdp3wqjQ3Pvp$ACQhV1lBpdcnsN$etpxdL95c6EVBbL#DnZd6ESOwdC8RaxbUSaSM" +
		"GeCYHuXD3eYPzY0ZLthV7ADef$3shzlezIT7g9xkxO#sZhG$M1w6k5VOxm$9XZBo$vxV7ol" +
		"qqovy2wvHe#dS4FakPqH$9A72AUDQfTpuO2qVJaWNHDjcjUJW7Bu#gZwENx6H9BvWZ4MwbP" +
		"qVGkCoddSmHnOgenhlJqLfncMCZSvnJd5ESKvnJd5ESKvnJd5ESKvnJd5ESKu7dPFP2Fazh" +
		"VLA6Ky2#ANVVblI#9z3dduCqHMHFivlwSSzDcqZUeX#dF3MKsVdlITP9wVdja4sL4kvv3#G" +
		"qJsiySZhSRy36x4Z9eHU$tmvHKshlqLe$L$Px1q9xcYJTRoUUHZzAxnkmKr2dt$EgwoRI8f" +
		"odq5AT2$Yc0qhcqqPQg7LROgJhakClYsswzk7ULq79kNZ7mn3zlpOgdUcnrHXZm$41kawZI" +
		"IZDzD5r1c2Mpi$LvnRPta6sVu6L1HxUj#zwPJ6sejzXgo7QLghqS8W8D9$6A5jXPCRJJ9gk" +
		"Ha2gtsdDqV$9kOXce6uMDCkYkPg7zyq8gjynvksxOsYpMqlWIHxjVJIZ0#0o5pJkzunwv7R" +
		"R4LnK3vkqVReOIR9i#w3EbaJLpNNNeKJL7RFhRDjvP0goa6#FXcQ8zXBxLsrkgi2olIZPPE" +
		"pgbT8UqPb6r#AmM9QkMuGUoxZjuEt9qwFjtJNf9voN6jspl5Gw$nFyrqHozo$ktMy$3XYzs" +
		"Q5AWsce7U3ki1HxSi75q915v4XwplxNnW4uPH293ym$5zuC#0JvlrHzVW1uFu7J3ZljQcPZ" +
		"EkYjR$0YKPMzm2EGEGIyWgXgQszzsHxv9Tkf1kZw1tGTGjIm8c790dm1KSLNWHyWIgq6$0f" +
		"m8U2HgB$JRjDmDSRnX9i71dYNAVyRvUcWcqHKUwnTHkVOkAwmSRMofrhdxEtHg39aV2oud0" +
		"i3Qg3#Ok1NZ4uraPvgfnDdegu3sYuFQDVNFrzb3Ch#Wdrw0X#5RxR3tBW5k8rTB#v4VhnfU" +
		"v4fwmRU0v5OJdH6A#I$07uXWEzW6plEi77DTYRVoCZQqUJdUDlKXi$J6bF$Eb7fGQX$BdTs" +
		"gZkEg7e3o0Lz2jT7kykHNclNLNz5pNgL1le7TUkDZLxrjaye1leJeDqJp3kXF56TIdQwHYi" +
		"RDuPprlWSF0vxwMX5SDl2lw1zPm1YJC9TW3A0D1$UNS3h4YIsmOQJZ5pt8RtVdq#T2q7RbI" +
		"WDuvtG4d0$u7708qOUzE6O6o3tHz0NyodXKfF$rE1LWEvssdKRqb$ujwlG5sEwqD1E1Kr9u" +
		"BUyzOKAUzFycusBxFNdqVWDpDjzThheDMY$cEWi9Vl7W1#9d4s0txFhpq9$ZdacFSlq#xx1" +
		"I$pv9aqq$NvZPAaSeFD2el89Flcb1Yyp6B4YmG4OwaEJ1PrDludjJTdlu0t$JfZkGtV4loy" +
		"UuKqJuXCZRXTZq1q486xN$HFy5fcsIDUvpauddslZOW$23WqnfjUZ7hxdH7nplWceRzSxuS" +
		"$5CI#TY85EpEN6twEFuqWR7tHsGfdwF#gceFlMb3s4kGRREk7$zS3RUG$mZS20ujiCpKj4v" +
		"mAByv3kPSeQ8V#MqMKkyZUPyiOsFXUnXg#4BnZxrzs3#Ga#pjcG$oxWjm0J0T3R#Pg$dPpl" +
		"0ju3VyILekyZ$O4f$yY7PXVuA1vZ0UjXjsk1H$hKVuknBsVIcElbuKkE1T1DoG1vwtq7Z3Z" +
		"$lmLc79T1PjX0t86o4qQ7HuWgOQwTsSZBLy0tdSPFwsr76Zphu$hYnFYVUQzTNWdnxTotGV" +
		"iHojurl2QgluP6VhwTTpbHjXaqyEyp$x7Bci3FpcvBLAAXdI$VryOEsCpvAm3nDkrd#0Nci" +
		"VCmqiTG1ncTH#0RIy0B#IJCNyTDeEaFG3k6tSjTuvNVCHhqeAcV2PrXlyJYY3cuNYQM041N" +
		"1soLeDAN0c2Fn0hUjccubYRUuCqtgGLv9nlxGO$oiu0nNecRJ1daISGrjOBnlyG$lMqh9i0" +
		"6FcFk4W3expeBWFZfgW2e1BWLS3i0u#B2jSK5#xXmpN71XrpmLTTJ0FXbawkWFzPX9LGPva" +
		"29Tu1x0Pu6uDhJ1DSWyGFAvo7$36J1l2#1kU5w5W0HNBq1pnELn1nouLhYWhsRA1#SXhHg0" +
		"rzn7K3P5DW8ifQy6tcaNV3VsfWhBiIh#aeMZ4FzmS0pG0CVSAs3$j3LWR6kZpZgmZMhFcpY" +
		"seXw#A5h4m0nlWdYkGDq9LKTQ5CIYIgN8og5QvDh2zOvIYvS6ngq0GPjAQK$VA4oV26bBjh" +
		"2JgKmdabbaSTSg8mrOAavoCEUIUDH1Ze7OdSfNBkJOD#K3t7DnNmlNGzvpnZROv42dPFAsE" +
		"cawm28DoBDbyRumwEGuHlK6tzDmjef2R4aAGMGQihKFw73bYxC3nTyrWLVhOYvw3fgrvV#6" +
		"ZI8LmxOC0dbPSu4DlwIr1e#NCpRNz8L1byDQ6kdcoOX3LzFUjduzyj8#rq3xF9qXuz#Ew3x" +
		"03jT5#FZCFCv$Np4SCpBUbX35N91bYVjyeHIDYwpoKSM#5gvSS7ziE6RbEHVNcPr86sq03Q" +
		"ivKrNsAamhkDxlMNdO5uHR4GP9dyNJZjzPBuklsGxrG1TiHv9QenrBNm#2MkYQayYtZq6ZB" +
		"bO136XEkgAmcUg8qPKt6ZiWNX33Tqyr5BGBXTcJL3fNPG5h3CSDKtTOT$oWWRG4p7ax16Xw" +
		"mXr3X#$g76fDrqPQuyQQu5dPSSVTjbZqwVDyBOjtDY$dx9TW$jEkDZ6vKROEBcAVxte7P1V" +
		"4D1#I31Ff$2ciTKXHyliPFTlMnlhzIguJjJ1DQJA1iDlheshOlr49luu4hnjqhxsvr47iRt" +
		"gEy6ywGhmkjlm#jt6zH0Rpy7Q8gsqbyxnUN3R8bNzyuMt1zEuQjiu#J9lMOtN$Mcug95vXm" +
		"$lXjwqwyLWlWbOqn6kQOvL9b$7ncUCyjAK$Jf4kzlX5rkzUUVY07iCyqcRTMbwSt#Qr0JOn" +
		"wpXqxiQsRjwwujUuasdt#jJljBmTQ#h0#oNjjK$drudMFxIpthJmkphn3EcFTO5wRU5qFaJ" +
		"tppqnxKwlNqWdNyRuTCF8MubO1sJ$hXFVMSVVbiHpynUgbeX8tjV8zEJtZQ5$EvNm2UwUTE" +
		"59mNBK2pDqFcijHFljx7ha8sBhhDnpMfUcZEE6BtVCVA$xxO1Ze#zTFR#26jiSs#W#9T6Dw" +
		"nJH0MZXyj7Ve$#eG2wSlYwT9#vL6XbSFt$VFcOUnR5zzguT6#ZuvLUcZB6$se#RkDKo5mD#" +
		"xYQWxmqAkGuMnWUkqsxgqmx4p#gpSGyCNlicWSDBwplgbSXgdMMbrUvlZQkTQ6XkGWqMC$M" +
		"wcHaTjZOqGfzchMAsjCufvZq3rvUjTusj9c65$PM5VUhlHLYmNF1jgaqpBsVmff2xNC#2QG" +
		"9RkDSwfzFnTwo#dfllinhDaxyp9$EqIAOL#AFEVKN2U2Qbs3ZSljjV5RzWFeVJFb3th9I1t" +
		"rfxB9QKxtfojs3woklDdnyzlf5ZC#Ngs7ZYiqDZP4b$LfJRlQvbMwmSNcFZBW66TkLVyZ6g" +
		"TYhrC1wkxovNfvjxezLhcxe3EyQs6DK#TLELp3t2LAnhqaPXBoFhbKlCpI6NohMzIb3aFUx" +
		"hsHeXmQN5Viuk8pK$ggtD#$g74XZw2p$FC$qfjC7#jUb3$RFE$pk8mRpBeJzZMk0DvzKEJH" +
		"TOZrlEdKwvfOP8#SJtdLVKd#3pNseYW7taj8h1lGznp$lIAA0GvujAyeAyd9vcRnKNY9Ror" +
		"RoOdcHl51U8C#NBMKBcIcRoxgoZgmjpz7qs1t9$ydIyWnP2gdF3PV#ybc9lQViBW$9W$A0$" +
		"4tkbx$AN#G#kLVkaRlbBhbJxf3RvSzoczmgjyZDSfFSA3V8zNATN2lNo9$aQhbAhfGhv7Av" +
		"J2wLI#HYUKB#8u$Bl#LVya$vXpmcZyeZyh3yNSwKC#GiYLMqn8vIFcOam4vGTW4y8Z$J#S7" +
		"oKvpXO$9Z#GBE7m6muvJlo$Ta1zbUjfDjvPto3dcxl4tUAc#HDykRv8soZRn1NY#lazVAQ#" +
		"JLyYfvfRn2lYdVaA$Br#H0#QeS85#HBykNv8lMxTPjyXtvjiIELxuh#yc#iezyNlOsqZoZp" +
		"xqahf$o2TbDTfKFouTaPzb9TlItlpLEKy97h3$yoe$9P8dLZeKLhxK6y1DWDG2x1ckbdAPR" +
		"BJAzpPSFoWVa$V8#UQ#yHzujxx8#j11LhVSrfs7M5w0PhIc$0uoGt#ZqrtAUd2ldoDdo1#I" +
		"co8bo0l0OmBVoAvo7oE4oo$fStN$sIFMPhEH9hv28hjPSQxOrAq2d2VeyNKwNF#hKZnPwiA" +
		"ReNYlBAaXFbBLaJLttdcdpZWLBMWEjLt4U0BfXSgZyKhVu8e3xO5sAtPGi2pyi2Ln25fL5W" +
		"0i32W6IfB1EQDf$hEEojFKtu2#b9UgSbgLh$aGwmPGv9CcfSfmSQqbmP5a6PG$1ssR3Eies" +
		"a$LvaXmllm#GPL10$h0dzJi57DO1JsgPjHJdnJgzo5fYBT1ILBNc1xNvH9ubo$dalmLyROt" +
		"me$dOMgXRpxCE1hJ#pPFwnU0zihYrtbedY$bGxLVpGwT#DNYlfswVmRi16rHBEs$B91y8b5" +
		"S#BNlW$B1EtwVFz#lpN3aF75wnNjFSthRUr7YQfv#f1iE#rX2vKBTPO1rrnoMTrt59fqnS2" +
		"kYxXa$w8Sqjm2zznoVlXzjgsT9yODrYtGhyYNwOeoHutdhEUjPwnkIUzaZMox#brSalrqMV" +
		"7xOUiZfPZ#Zq4wP6nnEhWzNUUj32U5ZtMzhkrhtMU9pVzU5n3#1km5rME#iEu3kjjXRY5MT" +
		"n4Z50wFzRZmIo2Y0yImw002G04kbvbFd24u373Jm9w0vu1e0hBe2f3zhRuAILu6D3WeOvIC" +
		"y1pIfWzVsW8sXp1Fc#g5i2l0JjvWFFDtYiWN4#y3tg5gBjA40tvBiXlnzuF$A$QN3G1y0V0" +
		"1z5#L7W3S0RKFO9i1i#ZW3wQN1G3#1WI008Wnq6X0yu0j8Ad3xjtMN1l1yry5GEy64kuAC8" +
		"uSKym5TvW9S1N$h0PmPUDV2DWPS0AkwhVrVi3$kDXdr78ptSmASe6moiO2FI6u7LrUe7uAM" +
		"WLV02okTfO9g9l88XI2iOYlHGr0t5k6Bj060QXlGmb0t3l3W6V0nb1u0F06y6$IRWJSYF1n" +
		"wF$1Z09C0hW07a0ZZfQ#3tD3Xf9FYE1ErxL0XG691awjpOc$vEWnDG250Oa6JAtDYRNeF#5" +
		"e6lWe583uHChm6$1lmwyEl0Ru3N2C3x0AoH04n$eFmFvBSWlGLqow3lGPIz2VWMi1Nb2luq" +
		"y1RAtlP00Xr2stLeznVg5Bo3z238fAvEKv7lXVHXu1aQr5D7Dk2WMHgOVWHC0qm0JDP0r1j" +
		"rFP5MyBS61qq4dWXT9uBdxqXF0VuSjdaQi1ZvvpG8W8E#80UxWBT1ncqQAn3qCs0xw7Pe4B" +
		"GSUBcDEG6HFG5O01o0HEGJWHdW1Drnq1q7tka3#y1$7tZ$WxGN71fE8BqBU3VQxTOuWLOWR" +
		"I5jeMuFy1xWNm6p0R#WtWO7G1Xm672I#kwVH5fI0cDZ0c3QY$nUuCS0NG6h0Ui1x$uV2nmt" +
		"PG==");

	private WorkingParseResult fWorking;

	// Collect the errors into a list of IParseErrors and let the custom error recovery mechanism handle it
	private class JSEvents extends Events
	{
		public void scannerError(Scanner.Exception e)
		{
		}

		public void syntaxError(Symbol token)
		{
			if (token != null && fWorking != null)
			{
				fWorking.addError(new ParseError(IJSConstants.CONTENT_TYPE_JS, token, IParseError.Severity.ERROR));
			}
		}

		public void unexpectedTokenRemoved(Symbol token)
		{
		}

		public void missingTokenInserted(Symbol token)
		{
		}

		public void missingTokensInserted(List<Symbol> tokens)
		{
			if (tokens != null && tokens.size() == 1 && tokens.get(0).getId() == Terminals.SEMICOLON)
			{
				// remove last error
				if (fWorking != null)
				{
					List<IParseError> errors = fWorking.getErrors();
					IParseError lastError = (errors.isEmpty()) ? null : errors.get(errors.size() - 1);

					if (lastError != null)
					{
						fWorking.removeError(lastError);
					}
				}
			}

			super.missingTokensInserted(tokens);
		}

		public void misspelledTokenReplaced(Symbol token)
		{
		}

		public void errorPhraseRemoved(Symbol error)
		{
		}
	}

	private final List<IRecoveryStrategy> recoveryStrategies;
	private JSFlexScanner fScanner;
	private IProblem.Severity fSemicolonSeverity = IProblem.Severity.WARNING;

    /**
     * attachPostDocumentationBlocks
     * 
     * @param root
     * @param source
     */
    private void attachPostDocumentationBlocks(JSParseRootNode root, String source)
    {
        // process each post-documentation block
        for (Symbol block : this.fScanner.getVSDocComments())
        {
            int index = block.getStart() - 1;

            while (index >= 0 && Character.isWhitespace(source.charAt(index)))
            {
                index--;
            }

            IParseNode node = root.getNodeAtOffset(index);

            if (node instanceof JSNode)
            {
                switch (node.getNodeType())
                {
                    case IJSNodeTypes.STATEMENTS:
                        IParseNode parent = node.getParent();

                        if (parent.getNodeType() == IJSNodeTypes.FUNCTION)
                        {
                            ((JSNode) parent).setPostDocumentation(block);
                        }
                        break;

                    default:
                        ((JSNode) node).setPostDocumentation(block);
                        break;
                }
            }
        }
    }

    /**
     * attachPreDocumentationBlocks
     * 
     * @param root
     * @param source
     */
    private void attachPreDocumentationBlocks(JSParseRootNode root, String source)
    {
        // process each pre-documentation block
        List<Symbol> sDocComments = fScanner.getSDocComments();
        for (Symbol comment : sDocComments)
        {
            int index = comment.getEnd() + 1;

            while (index < source.length() && Character.isWhitespace(source.charAt(index)))
            {
                index++;
            }

            IParseNode node = root.getNodeAtOffset(index);

            if (node instanceof JSNode)
            {
                if (node instanceof JSGroupNode && node.getFirstChild() instanceof JSFunctionNode)
                {
                    ((JSNode) node.getFirstChild()).setPreDocumentation(comment);
                }
                else if (node instanceof JSIdentifierNode && node.getParent() instanceof JSNameValuePairNode)
                {
                    // associate documentation with property's value
                    JSNameValuePairNode entry = (JSNameValuePairNode) node.getParent();
                    ((JSNode) entry.getValue()).setPreDocumentation(comment);
                }
                else
                {
                    IParseNode statement = ((JSNode) node).getContainingStatementNode();

                    if (statement instanceof JSAssignmentNode)
                    {
                        ((JSNode) statement.getLastChild()).setPreDocumentation(comment);
                    }
                    else
                    {
                        switch (node.getNodeType())
                        {
                            case IJSNodeTypes.VAR:
                                // associate documentation with first declared variable's value
                                JSVarNode varNode = (JSVarNode) node;
                                ((JSNode) varNode.getFirstChild().getLastChild()).setPreDocumentation(comment);
                                break;

                            default:
                                ((JSNode) node).setPreDocumentation(comment);
                                break;
                        }
                    }
                }
            }
        }
    }

	/**
	 * getNextSymbolIndex
	 * 
	 * @return
	 */
	protected Symbol getLastSymbol()
	{
		Symbol result = null;

		if (0 <= this.top && this.top < this._symbols.length)
		{
			result = this._symbols[this.top];
		}

		return result;
	}

    public synchronized ParseResult parse(IParseState parseState) throws java.lang.Exception
    {
        WorkingParseResult working = new WorkingParseResult();
        parse(parseState, working);
        return working.getImmutableResult();
    }


	/*
	 * (non-Javadoc)
	 * @see com.aptana.parsing.IParser#parse(com.aptana.parsing.IParseState)
	 */
	protected synchronized void parse(IParseState parseState, WorkingParseResult working) throws java.lang.Exception
	{
		fWorking = working;
		String severity = Platform.getPreferencesService().getString(JSCorePlugin.PLUGIN_ID, IPreferenceConstants.PREF_MISSING_SEMICOLON_SEVERITY, null, null);
		fSemicolonSeverity = IProblem.Severity.create(severity);

		// make sure we have some source
		String source = parseState.getSource();

		// create scanner and send source to it
		fScanner = new JSFlexScanner();
		fScanner.setSource(source);

		// determine if we need to collect and/or attach comments
		boolean attachComments = true;
		boolean collectComments = true;

		if (parseState instanceof JSParseState)
		{
			JSParseState jsParseState = (JSParseState) parseState;

			// NOTE: In order to attach comments, we have to collect them, hence the OR in collectComments
			attachComments = jsParseState.attachComments();
			collectComments = jsParseState.attachComments() || jsParseState.collectComments();
		}

		fScanner.setCollectComments(collectComments);

		try
		{
			JSParseRootNode result;
			try
			{
				// parse
				result = (JSParseRootNode) parse(fScanner);

				if (attachComments)
				{
					attachComments(source, result);
				}

				if (collectComments)
				{
					collectComments(result);
				}
			}
			finally
			{
				// clear scanner for garbage collection
				if (fScanner != null)
				{
					fScanner.yyclose();
					fScanner = null;
				}
			}

			// update node offsets
			int start = parseState.getStartingOffset();
			int length = source.length();

			// align root with zero-based offset
			result.setLocation(0, length - 1);

			if (start != 0)
			{
				// shift all offsets to the correct position
				ParseUtil.addOffset(result, start);
			}

			// store results in the parse state
			fWorking.setParseResult(result);
		}
		finally
		{
			fWorking = null;
		}
	}

	
    private void attachComments(String source, JSParseRootNode result)
    {
        // attach documentation
        attachPreDocumentationBlocks(result, source);
        attachPostDocumentationBlocks(result, source);
    }

    private void collectComments(JSParseRootNode result)
    {
        // create a list of all comments and attach to root node

        List<Symbol> sDocComments = fScanner.getSDocComments();
        List<Symbol> vsDocComments = fScanner.getVSDocComments();
        List<Symbol> singleLineComments = fScanner.getSingleLineComments();
        List<Symbol> multiLineComments = fScanner.getMultiLineComments();

        List<JSCommentNode> comments = new ArrayList<JSCommentNode>(sDocComments.size() + vsDocComments.size()
                + singleLineComments.size() + multiLineComments.size());

        for (Symbol symbol : sDocComments)
        {
            comments.add(new JSCommentNode(IJSNodeTypes.SDOC_COMMENT, symbol.getStart(), symbol.getEnd()));
        }

        for (Symbol symbol : vsDocComments)
        {
            comments.add(new JSCommentNode(IJSNodeTypes.VSDOC_COMMENT, symbol.getStart(), symbol.getEnd()));
        }

        for (Symbol symbol : singleLineComments)
        {
            comments.add(new JSCommentNode(IJSNodeTypes.SINGLE_LINE_COMMENT, symbol.getStart(), symbol.getEnd()));
        }

        for (Symbol symbol : multiLineComments)
        {
            comments.add(new JSCommentNode(IJSNodeTypes.MULTI_LINE_COMMENT, symbol.getStart(), symbol.getEnd()));
        }

        result.setCommentNodes(comments.toArray(new IParseNode[comments.size()]));
    }

	/*
	 * (non-Javadoc)
	 * @see beaver.Parser#recoverFromError(beaver.Symbol, beaver.Parser.TokenStream)
	 */
	@Override
	protected void recoverFromError(Symbol token, TokenStream in) throws IOException, Parser.Exception
	{
		boolean success = false;

		if (this.recoveryStrategies != null)
		{
			// NOTE: Consider building a Map<Object,List<IRecoveryStrategy>> which
			// would allow us to reduce the number of recovery strategies that will
			// be attempted based on the last symbol on the stack. We may need
			// catch-all cases: 1) try these before the mapped strategies, 2)
			// try the strategies, 3) try these after the mapped strategies
			for (IRecoveryStrategy strategy : this.recoveryStrategies)
			{
				if (strategy.recover(this, getLastSymbol(), token, in, report))
				{
					success = true;
					break;
				}
			}
		}

		if (success == false)
		{
			super.recoverFromError(token, in);
		}
	}

	public JSParser() {
		super(PARSING_TABLES);


		report = new JSEvents();

		// @formatter:off
		recoveryStrategies = new ArrayList<IRecoveryStrategy>(10);

		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.SEMICOLON, ";")
		{
			public boolean recover(IParser parser, Symbol lastToken, Symbol currentToken, TokenStream in, Events report)
					throws IOException
			{
				boolean recovered = super.recover(parser, lastToken, currentToken, in, report);
				if (recovered && fSemicolonSeverity != IProblem.Severity.IGNORE)
				{
					fWorking.addError(new ParseError(IJSConstants.CONTENT_TYPE_JS, lastToken, Messages.JSParser_MissingSemicolonMsg, fSemicolonSeverity));
				}
				return recovered;
			}
		});
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.RPAREN, ")", JSTokenType.SEMICOLON, ";"));
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.IDENTIFIER, "", JSTokenType.SEMICOLON, ";", JSTokenType.DOT, JSTokenType.NEW, JSTokenType.EQUAL));
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.IDENTIFIER, "", JSTokenType.DOT, JSTokenType.NEW, JSTokenType.EQUAL));
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.IDENTIFIER, "", JSTokenType.LPAREN));
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.IDENTIFIER, "", JSTokenType.COLON, ":", JSTokenType.DOT));
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.LCURLY, "{", JSTokenType.RCURLY, "}", JSTokenType.RPAREN));
		recoveryStrategies.add(new IRecoveryStrategy()
		{
			public boolean recover(IParser parser, Symbol lastToken, Symbol currentToken, TokenStream in, Parser.Events report) throws IOException
			{
				boolean result = false;

				if (top >= 2)
				{
					Symbol symbol1 = _symbols[top - 2];
					Symbol symbol2 = _symbols[top - 1];

					if (lastToken.getId() == JSTokenType.COMMA.getIndex() && symbol2.value instanceof List<?> && symbol1.getId() == JSTokenType.LPAREN.getIndex())
					{
						Symbol term = new Symbol(JSTokenType.IDENTIFIER.getIndex(), currentToken.getStart(), currentToken.getStart() - 1, "");
						Simulator sim = new Simulator();

						in.alloc(2);
						in.insert(term, currentToken);
						in.rewind();

						if (sim.parse(in))
						{
							result = true;

							in.rewind();

							report.missingTokenInserted(term);
						}
					}
				}

				return result;
			}
		});

		JSInsertionRecoveryStrategy completeProperty = new JSInsertionRecoveryStrategy(JSTokenType.IDENTIFIER, "");
		completeProperty.addCurrentTokenTypes(JSTokenType.RCURLY);
		recoveryStrategies.add(completeProperty);

		JSInsertionRecoveryStrategy completeProperty2 = new JSInsertionRecoveryStrategy(JSTokenType.COLON, ":", JSTokenType.IDENTIFIER, "");
		completeProperty2.addCurrentTokenTypes(JSTokenType.RCURLY);
		recoveryStrategies.add(completeProperty2);
		// @formatter:on
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 51: // CoverParenthesizedExpressionAndArrowParameterList = LPAREN.l Expression.e RPAREN.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 3];
					
			return new JSGroupNode(l, e, r);
			}
			case 59: // NullLiteral = NULL.n
			{
					final Symbol n = _symbols[offset + 1];
					
			return new JSNullNode(n);
			}
			case 60: // BooleanLiteral = TRUE.t
			{
					final Symbol t = _symbols[offset + 1];
					
			return new JSTrueNode(t);
			}
			case 61: // BooleanLiteral = FALSE.f
			{
					final Symbol f = _symbols[offset + 1];
					
			return new JSFalseNode(f);
			}
			case 62: // NumericLiteral = NUMBER.n
			{
					final Symbol n = _symbols[offset + 1];
					
			return new JSNumberNode(n);
			}
			case 63: // StringLiteral = STRING.s
			{
					final Symbol s = _symbols[offset + 1];
					
			return new JSStringNode(s);
			}
			case 64: // RegularExpressionLiteral = REGEX.r
			{
					final Symbol r = _symbols[offset + 1];
					
			return new JSRegexNode(r);
			}
			case 67: // ArrayLiteral = LBRACKET.l opt$Elision.e RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSElisionNode e = (JSElisionNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 3];
					
			if (e == null) {
				return new JSArrayNode(l, r);
			}
			e.addChild(new JSNullNode());
			return new JSArrayNode(l, r, e);
			}
			case 68: // ArrayLiteral = LBRACKET.l ElementList.e RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSElementsNode e = (JSElementsNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 3];
					
			return new JSArrayNode(l, r, e);
			}
			case 69: // ArrayLiteral = LBRACKET.l ElementList.e COMMA opt$Elision.n RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSElementsNode e = (JSElementsNode) _symbol_e.value;
					final Symbol _symbol_n = _symbols[offset + 4];
					final JSElisionNode n = (JSElisionNode) _symbol_n.value;
					final Symbol r = _symbols[offset + 5];
					
			if (n == null) {
				return new JSArrayNode(l, r, e, new JSNullNode());
			}
			n.addChild(new JSNullNode());
			return new JSArrayNode(l, r, e, n);
			}
			case 70: // ElementList = opt$Elision.n SingleExpression.e
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final JSElisionNode n = (JSElisionNode) _symbol_n.value;
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			if (n == null) {
				return new JSElementsNode(e);
			}
			return new JSElementsNode(n, e);
			}
			case 72: // ElementList = ElementList.l COMMA opt$Elision.n SingleExpression.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSElementsNode l = (JSElementsNode) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 3];
					final JSElisionNode n = (JSElisionNode) _symbol_n.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final JSNode e = (JSNode) _symbol_e.value;
					
			if (n != null) {
				l.addChild(n);
			}
			l.addChild(e);

			return l;
			}
			case 74: // Elision = Elision.e COMMA
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSElisionNode e = (JSElisionNode) _symbol_e.value;
					
			e.addChild(new JSNullNode());

			return e;
			}
			case 75: // Elision = COMMA
			{
					
			return new JSElisionNode(new JSNullNode());
			}
			case 77: // ObjectLiteral = LCURLY.l RCURLY.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol r = _symbols[offset + 2];
					
			return new JSObjectNode(l, r);
			}
			case 80: // ObjectLiteral = LCURLY.l PropertyDefinitionList.p opt$COMMA RCURLY.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_p = _symbols[offset + 2];
					final ArrayList _list_p = (ArrayList) _symbol_p.value;
					final JSNode[] p = _list_p == null ? new JSNode[0] : (JSNode[]) _list_p.toArray(new JSNode[_list_p.size()]);
					final Symbol r = _symbols[offset + 4];
					
			return new JSObjectNode(l, r, p);
			}
			case 81: // PropertyDefinitionList = PropertyDefinition
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 82: // PropertyDefinitionList = PropertyDefinitionList COMMA PropertyDefinition
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 84: // PropertyDefinition = PropertyName.n COLON.c SingleExpression.v
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final JSNode n = (JSNode) _symbol_n.value;
					final Symbol c = _symbols[offset + 2];
					final Symbol _symbol_v = _symbols[offset + 3];
					final JSNode v = (JSNode) _symbol_v.value;
					
			return new JSNameValuePairNode(n, c, v);
			}
			case 88: // LiteralPropertyName = IdentifierName.i
			{
					final Symbol i = _symbols[offset + 1];
					
			return new JSIdentifierNode(i);
			}
			case 92: // CoverInitializedName = Identifier.i Initializer.z
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol _symbol_z = _symbols[offset + 2];
					final JSInitializerNode z = (JSInitializerNode) _symbol_z.value;
					
			return new JSDeclarationNode(new JSIdentifierNode(i), z.getEquals(), z.getExpression());
			}
			case 93: // Initializer = EQUAL.e SingleExpression.expr
			{
					final Symbol e = _symbols[offset + 1];
					final Symbol _symbol_expr = _symbols[offset + 2];
					final JSNode expr = (JSNode) _symbol_expr.value;
					
			return new JSInitializerNode(e, expr);
			}
			case 100: // Arguments = LPAREN RPAREN
			{
					
			return new JSArgumentsNode();
			}
			case 101: // Arguments = LPAREN ArgumentList.a RPAREN
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final ArrayList _list_a = (ArrayList) _symbol_a.value;
					final JSNode[] a = _list_a == null ? new JSNode[0] : (JSNode[]) _list_a.toArray(new JSNode[_list_a.size()]);
					
			return new JSArgumentsNode(a);
			}
			case 102: // ArgumentList = ArgumentListItem
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 103: // ArgumentList = ArgumentList COMMA ArgumentListItem
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 121: // Expression = Expression.l COMMA SingleExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSCommaNode(l, r);
			}
			case 127: // SingleExpression = SingleExpression.l LBRACKET.lb Expression.r RBRACKET.rb
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol lb = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					final Symbol rb = _symbols[offset + 4];
					
			return new JSGetElementNode(l, lb, r, rb);
			}
			case 132: // SingleExpression = NEW SingleExpression.e
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			// FIXME The second argument should be the Arguments node here
			return new JSConstructNode(e, new JSEmptyNode(e));
			}
			case 133: // SingleExpression = SingleExpression.l Arguments.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 2];
					final JSArgumentsNode r = (JSArgumentsNode) _symbol_r.value;
					
			return new JSInvokeNode(l, r);
			}
			case 135: // SingleExpression = SingleExpression.l DOT.o IdentifierName.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol r = _symbols[offset + 3];
					
			return new JSGetPropertyNode(l, o, new JSIdentifierNode(r));
			}
			case 136: // SingleExpression = SingleExpression.e PostUnaryOperator.o
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol o = _symbols[offset + 2];
					
			return new JSPostUnaryOperatorNode(o, e);
			}
			case 137: // SingleExpression = PreUnaryOperator.o SingleExpression.e
			{
					final Symbol o = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			return new JSPreUnaryOperatorNode(o, e);
			}
			case 138: // SingleExpression = SingleExpression.l BinaryArithmeticOperator.o SingleExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryArithmeticOperatorNode(l, o, r);
			}
			case 139: // SingleExpression = SingleExpression.l BinaryBooleanOperator.o SingleExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryBooleanOperatorNode(l, o, r);
			}
			case 140: // SingleExpression = SingleExpression.l QUESTION.q SingleExpression.t COLON.c SingleExpression.f
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol q = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final JSNode t = (JSNode) _symbol_t.value;
					final Symbol c = _symbols[offset + 4];
					final Symbol _symbol_f = _symbols[offset + 5];
					final JSNode f = (JSNode) _symbol_f.value;
					
			return new JSConditionalNode(l, q, t, c, f);
			}
			case 143: // SingleExpression = SingleExpression.l EQUAL.o SingleExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSAssignmentNode(l, o, r);
			}
			case 144: // SingleExpression = SingleExpression.l AssignmentOperator.o SingleExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSAssignmentNode(l, o, r);
			}
			case 145: // SingleExpression = THIS.t
			{
					final Symbol t = _symbols[offset + 1];
					
			return new JSThisNode(t);
			}
			case 146: // SingleExpression = Identifier.i
			{
					final Symbol i = _symbols[offset + 1];
					
			return new JSIdentifierNode(i);
			}
			case 195: // Statement = error
			{
					
			return new JSErrorNode();
			}
			case 210: // Statement_NoIf = error
			{
					
			return new JSErrorNode();
			}
			case 211: // EmptyStatement = SEMICOLON.s
			{
					final Symbol s = _symbols[offset + 1];
					
			JSNode node = new JSEmptyNode(s);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 224: // Block = LCURLY opt$StatementList.a RCURLY
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final ArrayList _list_a = (ArrayList) _symbol_a.value;
					final JSNode[] a = _list_a == null ? new JSNode[0] : (JSNode[]) _list_a.toArray(new JSNode[_list_a.size()]);
					
			if (a == null) {
				return new JSStatementsNode();
			}
			return new JSStatementsNode(a);
			}
			case 225: // StatementList = StatementList StatementListItem
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 226: // StatementList = StatementListItem
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 229: // LexicalDeclaration = LetOrConst.v BindingList.l SEMICOLON
			{
					final Symbol v = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final ArrayList _list_l = (ArrayList) _symbol_l.value;
					final JSNode[] l = _list_l == null ? new JSNode[0] : (JSNode[]) _list_l.toArray(new JSNode[_list_l.size()]);
					
			JSNode node = new JSVarNode(v, l);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 232: // BindingList = BindingList COMMA LexicalBinding
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 233: // BindingList = LexicalBinding
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 236: // LexicalBinding = Identifier.i opt$Initializer.z
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol _symbol_z = _symbols[offset + 2];
					final JSInitializerNode z = (JSInitializerNode) _symbol_z.value;
					
			if (z == null) {
				return new JSDeclarationNode(new JSIdentifierNode(i), null, new JSEmptyNode(i));
			} else {
				return new JSDeclarationNode(new JSIdentifierNode(i), z.getEquals(), z.getExpression());
			}
			}
			case 238: // VariableStatement = VAR.v VariableDeclarationList.l SEMICOLON
			{
					final Symbol v = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final ArrayList _list_l = (ArrayList) _symbol_l.value;
					final JSNode[] l = _list_l == null ? new JSNode[0] : (JSNode[]) _list_l.toArray(new JSNode[_list_l.size()]);
					
			JSNode node = new JSVarNode(v, l);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 239: // VariableDeclarationList = VariableDeclarationList COMMA VariableDeclaration
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 240: // VariableDeclarationList = VariableDeclaration
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 241: // VariableDeclaration = Identifier.i opt$Initializer.z
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol _symbol_z = _symbols[offset + 2];
					final JSInitializerNode z = (JSInitializerNode) _symbol_z.value;
					
			if (z == null) {
				return new JSDeclarationNode(new JSIdentifierNode(i), null, new JSEmptyNode(i));
			} else {
				return new JSDeclarationNode(new JSIdentifierNode(i), z.getEquals(), z.getExpression());
			}
			}
			case 245: // ObjectBindingPattern = LCURLY.l RCURLY.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol r = _symbols[offset + 2];
					
			return new JSObjectNode(l, r);
			}
			case 246: // ObjectBindingPattern = LCURLY.l BindingPropertyList.p RCURLY.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_p = _symbols[offset + 2];
					final ArrayList _list_p = (ArrayList) _symbol_p.value;
					final JSNode[] p = _list_p == null ? new JSNode[0] : (JSNode[]) _list_p.toArray(new JSNode[_list_p.size()]);
					final Symbol r = _symbols[offset + 3];
					
			return new JSObjectNode(l, r, p);
			}
			case 247: // ObjectBindingPattern = LCURLY.l BindingPropertyList.p COMMA RCURLY.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_p = _symbols[offset + 2];
					final ArrayList _list_p = (ArrayList) _symbol_p.value;
					final JSNode[] p = _list_p == null ? new JSNode[0] : (JSNode[]) _list_p.toArray(new JSNode[_list_p.size()]);
					final Symbol r = _symbols[offset + 4];
					
			return new JSObjectNode(l, r, p);
			}
			case 250: // ArrayBindingPattern = LBRACKET.l opt$Elision.e opt$BindingRestElement.n RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSElisionNode e = (JSElisionNode) _symbol_e.value;
					final Symbol n = _symbols[offset + 3];
					final Symbol r = _symbols[offset + 4];
					
			// FIXME Handle elision, rest element
			return new JSArrayNode(l, r, e);
			}
			case 251: // ArrayBindingPattern = LBRACKET.l BindingElementList.n RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final ArrayList _list_n = (ArrayList) _symbol_n.value;
					final JSNode[] n = _list_n == null ? new JSNode[0] : (JSNode[]) _list_n.toArray(new JSNode[_list_n.size()]);
					final Symbol r = _symbols[offset + 3];
					
			return new JSArrayNode(l, r, n);
			}
			case 252: // ArrayBindingPattern = LBRACKET.l BindingElementList.n COMMA opt$Elision.e opt$BindingRestElement.z RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final ArrayList _list_n = (ArrayList) _symbol_n.value;
					final JSNode[] n = _list_n == null ? new JSNode[0] : (JSNode[]) _list_n.toArray(new JSNode[_list_n.size()]);
					final Symbol _symbol_e = _symbols[offset + 4];
					final JSElisionNode e = (JSElisionNode) _symbol_e.value;
					final Symbol z = _symbols[offset + 5];
					final Symbol r = _symbols[offset + 6];
					
			// FIXME Handle elision, rest element
			return new JSArrayNode(l, r, n);
			}
			case 253: // BindingPropertyList = BindingPropertyList COMMA BindingProperty
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 254: // BindingPropertyList = BindingProperty
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 255: // BindingElementList = BindingElementList COMMA BindingElisionElement
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 256: // BindingElementList = BindingElisionElement
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 259: // BindingProperty = PropertyName.n COLON.c BindingElement.e
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final JSNode n = (JSNode) _symbol_n.value;
					final Symbol c = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					
			return new JSNameValuePairNode(n, c, e);
			}
			case 262: // SingleNameBinding = Identifier.i opt$Initializer.z
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol _symbol_z = _symbols[offset + 2];
					final JSInitializerNode z = (JSInitializerNode) _symbol_z.value;
					
			if (z == null) {
				return new JSIdentifierNode(i);
			}
			return new JSDeclarationNode(new JSIdentifierNode(i), z.getEquals(), z.getExpression());
			}
			case 264: // ExpressionStatement = Expression.e SEMICOLON
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSNode e = (JSNode) _symbol_e.value;
					
			e.setSemicolonIncluded(true);
			return e;
			}
			case 265: // IfStatement = IF LPAREN.l Expression.e RPAREN.r Statement_NoIf.sn ELSE Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					final Symbol _symbol_sn = _symbols[offset + 5];
					final JSNode sn = (JSNode) _symbol_sn.value;
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSIfNode(l, e, r, sn, s);
			}
			case 266: // IfStatement = IF LPAREN.l Expression.e RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSIfNode(l, e, r, s, new JSEmptyNode(s));
			}
			case 267: // IfStatement_NoIf = IF LPAREN.l Expression.e RPAREN.r Statement_NoIf.sn ELSE Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					final Symbol _symbol_sn = _symbols[offset + 5];
					final JSNode sn = (JSNode) _symbol_sn.value;
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSIfNode(l, e, r, sn, s);
			}
			case 268: // IterationStatement = DO Statement.s WHILE LPAREN.l Expression.e RPAREN.r SEMICOLON.s1
			{
					final Symbol _symbol_s = _symbols[offset + 2];
					final JSNode s = (JSNode) _symbol_s.value;
					final Symbol l = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol s1 = _symbols[offset + 7];
					
 			JSNode node = new JSDoNode(s, l, e, r);
 			node.setSemicolonIncluded(true);
 			return node;
			}
			case 269: // IterationStatement = WHILE LPAREN.l Expression.e RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSWhileNode(l, e, r, s);
			}
			case 272: // IterationStatement = FOR LPAREN.l opt$Expression.e1 SEMICOLON.s1 opt$Expression.e2 SEMICOLON.s2 opt$Expression.e3 RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e1 = _symbols[offset + 3];
					final JSNode e1 = (JSNode) _symbol_e1.value;
					final Symbol s1 = _symbols[offset + 4];
					final Symbol _symbol_e2 = _symbols[offset + 5];
					final JSNode e2 = (JSNode) _symbol_e2.value;
					final Symbol s2 = _symbols[offset + 6];
					final Symbol _symbol_e3 = _symbols[offset + 7];
					final JSNode e3 = (JSNode) _symbol_e3.value;
					final Symbol r = _symbols[offset + 8];
					final Symbol _symbol_s = _symbols[offset + 9];
					final JSNode s = (JSNode) _symbol_s.value;
					
			JSNode expr1 = e1;
			if (expr1 == null) {
				expr1 = new JSEmptyNode(l);
			}
			JSNode expr2 = e2;
			if (expr2 == null) {
				expr2 = new JSEmptyNode(s1);
			}
			JSNode expr3 = e3;
			if (expr3 == null) {
				expr3 = new JSEmptyNode(s2);
			}
 			return new JSForNode(l, expr1, s1, expr2, s2, expr3, r, s);
			}
			case 273: // IterationStatement = FOR LPAREN.l VAR.v VariableDeclarationList.i SEMICOLON.s1 opt$Expression.e1 SEMICOLON.s2 opt$Expression.e2 RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayList _list_i = (ArrayList) _symbol_i.value;
					final JSNode[] i = _list_i == null ? new JSNode[0] : (JSNode[]) _list_i.toArray(new JSNode[_list_i.size()]);
					final Symbol s1 = _symbols[offset + 5];
					final Symbol _symbol_e1 = _symbols[offset + 6];
					final JSNode e1 = (JSNode) _symbol_e1.value;
					final Symbol s2 = _symbols[offset + 7];
					final Symbol _symbol_e2 = _symbols[offset + 8];
					final JSNode e2 = (JSNode) _symbol_e2.value;
					final Symbol r = _symbols[offset + 9];
					final Symbol _symbol_s = _symbols[offset + 10];
					final JSNode s = (JSNode) _symbol_s.value;
					
			JSNode expr1 = e1;
			if (expr1 == null) {
				expr1 = new JSEmptyNode(s1);
			}
			JSNode expr2 = e2;
			if (expr2 == null) {
				expr2 = new JSEmptyNode(s2);
			}
 			return new JSForNode(l, new JSVarNode(v, i), s1, expr1, s2, expr2, r, s);
			}
			case 274: // IterationStatement = FOR LPAREN.l LexicalDeclaration.decl opt$Expression.e1 SEMICOLON.s1 opt$Expression.e2 RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_decl = _symbols[offset + 3];
					final JSVarNode decl = (JSVarNode) _symbol_decl.value;
					final Symbol _symbol_e1 = _symbols[offset + 4];
					final JSNode e1 = (JSNode) _symbol_e1.value;
					final Symbol s1 = _symbols[offset + 5];
					final Symbol _symbol_e2 = _symbols[offset + 6];
					final JSNode e2 = (JSNode) _symbol_e2.value;
					final Symbol r = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
			JSNode expr1 = e1;
			if (expr1 == null) {
				expr1 = new JSEmptyNode(l);
			}
			JSNode expr2 = e2;
			if (expr2 == null) {
				expr2 = new JSEmptyNode(s1);
			}
			// FIXME Grab semicolon from decl to inject here?
 			return new JSForNode(l, decl, null, expr1, s1, expr2, r, s);
			}
			case 275: // IterationStatement = FOR LPAREN.l SingleExpression.i IN.in Expression.o RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol in = _symbols[offset + 4];
					final Symbol _symbol_o = _symbols[offset + 5];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForInNode(l, i, in, o, r, s);
			}
			case 276: // IterationStatement = FOR LPAREN.l VAR.v ForBinding.i IN.in Expression.o RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol in = _symbols[offset + 5];
					final Symbol _symbol_o = _symbols[offset + 6];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForInNode(l, new JSVarNode(v, i), in, o, r, s);
			}
			case 277: // IterationStatement = FOR LPAREN.l ForDeclaration.decl IN.in Expression.o RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_decl = _symbols[offset + 3];
					final JSNode decl = (JSNode) _symbol_decl.value;
					final Symbol in = _symbols[offset + 4];
					final Symbol _symbol_o = _symbols[offset + 5];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForInNode(l, decl, in, o, r, s);
			}
			case 278: // IterationStatement = FOR LPAREN.l SingleExpression.i OF.of SingleExpression.o RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol of = _symbols[offset + 4];
					final Symbol _symbol_o = _symbols[offset + 5];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForOfNode(l, i, of, o, r, s);
			}
			case 279: // IterationStatement = FOR LPAREN.l VAR.v ForBinding.i OF.of SingleExpression.o RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol of = _symbols[offset + 5];
					final Symbol _symbol_o = _symbols[offset + 6];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForOfNode(l, new JSVarNode(v, i), of, o, r, s);
			}
			case 280: // IterationStatement = FOR LPAREN.l ForDeclaration.decl OF.of SingleExpression.o RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_decl = _symbols[offset + 3];
					final JSNode decl = (JSNode) _symbol_decl.value;
					final Symbol of = _symbols[offset + 4];
					final Symbol _symbol_o = _symbols[offset + 5];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForOfNode(l, decl, of, o, r, s);
			}
			case 281: // IterationStatement_NoIf = DO Statement.s WHILE LPAREN.l Expression.e RPAREN.r SEMICOLON.s1
			{
					final Symbol _symbol_s = _symbols[offset + 2];
					final JSNode s = (JSNode) _symbol_s.value;
					final Symbol l = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol s1 = _symbols[offset + 7];
					
 			JSNode node = new JSDoNode(s, l, e, r);
 			node.setSemicolonIncluded(true);
 			return node;
			}
			case 282: // IterationStatement_NoIf = WHILE LPAREN.l Expression.e RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSWhileNode(l, e, r, s);
			}
			case 283: // IterationStatement_NoIf = FOR LPAREN.l opt$Expression.e1 SEMICOLON.s1 opt$Expression.e2 SEMICOLON.s2 opt$Expression.e3 RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e1 = _symbols[offset + 3];
					final JSNode e1 = (JSNode) _symbol_e1.value;
					final Symbol s1 = _symbols[offset + 4];
					final Symbol _symbol_e2 = _symbols[offset + 5];
					final JSNode e2 = (JSNode) _symbol_e2.value;
					final Symbol s2 = _symbols[offset + 6];
					final Symbol _symbol_e3 = _symbols[offset + 7];
					final JSNode e3 = (JSNode) _symbol_e3.value;
					final Symbol r = _symbols[offset + 8];
					final Symbol _symbol_s = _symbols[offset + 9];
					final JSNode s = (JSNode) _symbol_s.value;
					
			JSNode expr1 = e1;
			if (expr1 == null) {
				expr1 = new JSEmptyNode(l);
			}
			JSNode expr2 = e2;
			if (expr2 == null) {
				expr2 = new JSEmptyNode(s1);
			}
			JSNode expr3 = e3;
			if (expr3 == null) {
				expr3 = new JSEmptyNode(s2);
			}
 			return new JSForNode(l, expr1, s1, expr2, s2, expr3, r, s);
			}
			case 284: // IterationStatement_NoIf = FOR LPAREN.l VAR.v VariableDeclarationList.i SEMICOLON.s1 opt$Expression.e1 SEMICOLON.s2 opt$Expression.e2 RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayList _list_i = (ArrayList) _symbol_i.value;
					final JSNode[] i = _list_i == null ? new JSNode[0] : (JSNode[]) _list_i.toArray(new JSNode[_list_i.size()]);
					final Symbol s1 = _symbols[offset + 5];
					final Symbol _symbol_e1 = _symbols[offset + 6];
					final JSNode e1 = (JSNode) _symbol_e1.value;
					final Symbol s2 = _symbols[offset + 7];
					final Symbol _symbol_e2 = _symbols[offset + 8];
					final JSNode e2 = (JSNode) _symbol_e2.value;
					final Symbol r = _symbols[offset + 9];
					final Symbol _symbol_s = _symbols[offset + 10];
					final JSNode s = (JSNode) _symbol_s.value;
					
			JSNode expr1 = e1;
			if (expr1 == null) {
				expr1 = new JSEmptyNode(s1);
			}
			JSNode expr2 = e2;
			if (expr2 == null) {
				expr2 = new JSEmptyNode(s2);
			}
 			return new JSForNode(l, new JSVarNode(v, i), s1, expr1, s2, expr2, r, s);
			}
			case 285: // IterationStatement_NoIf = FOR LPAREN.l LexicalDeclaration.decl opt$Expression.e1 SEMICOLON.s1 opt$Expression.e2 RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_decl = _symbols[offset + 3];
					final JSVarNode decl = (JSVarNode) _symbol_decl.value;
					final Symbol _symbol_e1 = _symbols[offset + 4];
					final JSNode e1 = (JSNode) _symbol_e1.value;
					final Symbol s1 = _symbols[offset + 5];
					final Symbol _symbol_e2 = _symbols[offset + 6];
					final JSNode e2 = (JSNode) _symbol_e2.value;
					final Symbol r = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
			JSNode expr1 = e1;
			if (expr1 == null) {
				expr1 = new JSEmptyNode(l);
			}
			JSNode expr2 = e2;
			if (expr2 == null) {
				expr2 = new JSEmptyNode(s1);
			}
			// FIXME Grab semicolon from decl to inject here?
 			return new JSForNode(l, decl, null, expr1, s1, expr2, r, s);
			}
			case 286: // IterationStatement_NoIf = FOR LPAREN.l SingleExpression.i IN.in Expression.o RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol in = _symbols[offset + 4];
					final Symbol _symbol_o = _symbols[offset + 5];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForInNode(l, i, in, o, r, s);
			}
			case 287: // IterationStatement_NoIf = FOR LPAREN.l VAR.v ForBinding.i IN.in Expression.o RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol in = _symbols[offset + 5];
					final Symbol _symbol_o = _symbols[offset + 6];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForInNode(l, new JSVarNode(v, i), in, o, r, s);
			}
			case 288: // IterationStatement_NoIf = FOR LPAREN.l ForDeclaration.decl IN.in Expression.o RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_decl = _symbols[offset + 3];
					final JSNode decl = (JSNode) _symbol_decl.value;
					final Symbol in = _symbols[offset + 4];
					final Symbol _symbol_o = _symbols[offset + 5];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForInNode(l, decl, in, o, r, s);
			}
			case 289: // IterationStatement_NoIf = FOR LPAREN.l SingleExpression.i OF.of SingleExpression.o RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol of = _symbols[offset + 4];
					final Symbol _symbol_o = _symbols[offset + 5];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForOfNode(l, i, of, o, r, s);
			}
			case 290: // IterationStatement_NoIf = FOR LPAREN.l VAR.v ForBinding.i OF.of SingleExpression.o RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol of = _symbols[offset + 5];
					final Symbol _symbol_o = _symbols[offset + 6];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForOfNode(l, new JSVarNode(v, i), of, o, r, s);
			}
			case 291: // IterationStatement_NoIf = FOR LPAREN.l ForDeclaration.decl OF.of SingleExpression.o RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_decl = _symbols[offset + 3];
					final JSNode decl = (JSNode) _symbol_decl.value;
					final Symbol of = _symbols[offset + 4];
					final Symbol _symbol_o = _symbols[offset + 5];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForOfNode(l, decl, of, o, r, s);
			}
			case 293: // ForBinding = Identifier.i
			{
					final Symbol i = _symbols[offset + 1];
					
			return new JSIdentifierNode(i);
			}
			case 295: // ContinueStatement = CONTINUE SEMICOLON
			{
					
			JSNode node = new JSContinueNode();
			node.setSemicolonIncluded(true);
			return node;
			}
			case 296: // ContinueStatement = CONTINUE Identifier.i SEMICOLON
			{
					final Symbol i = _symbols[offset + 2];
					
			JSNode node = new JSContinueNode(i);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 297: // BreakStatement = BREAK SEMICOLON
			{
					
			JSNode node = new JSBreakNode();
			node.setSemicolonIncluded(true);
			return node;
			}
			case 298: // BreakStatement = BREAK Identifier.i SEMICOLON
			{
					final Symbol i = _symbols[offset + 2];
					
			JSNode node = new JSBreakNode(i);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 299: // ReturnStatement = RETURN.r SEMICOLON
			{
					final Symbol r = _symbols[offset + 1];
					
			JSNode node = new JSReturnNode(new JSEmptyNode(r));
			node.setSemicolonIncluded(true);
			return node;
			}
			case 300: // ReturnStatement = RETURN Expression.e SEMICOLON
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			JSNode node = new JSReturnNode(e);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 301: // WithStatement = WITH LPAREN.l Expression.e RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSWithNode(l, e, r, s);
			}
			case 302: // WithStatement_NoIf = WITH LPAREN.l Expression.e RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSWithNode(l, e, r, s);
			}
			case 303: // SwitchStatement = SWITCH LPAREN.lp Expression.e RPAREN.rp CaseBlock.children
			{
					final Symbol lp = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol rp = _symbols[offset + 4];
					final Symbol _symbol_children = _symbols[offset + 5];
					final ArrayList children = (ArrayList) _symbol_children.value;
					
			final JSNode[] c1 = children == null ? new JSNode[0] : (JSNode[]) children.toArray(new JSNode[children.size()]);
			return new JSSwitchNode(lp, e, rp, null, null, c1);
			}
			case 307: // CaseBlock = LCURLY opt$CaseClauses.c1 DefaultClause.d opt$CaseClauses.c2 RCURLY
			{
					final Symbol _symbol_c1 = _symbols[offset + 2];
					final ArrayList _list_c1 = (ArrayList) _symbol_c1.value;
					final JSCaseNode[] c1 = _list_c1 == null ? new JSCaseNode[0] : (JSCaseNode[]) _list_c1.toArray(new JSCaseNode[_list_c1.size()]);
					final Symbol _symbol_d = _symbols[offset + 3];
					final JSDefaultNode d = (JSDefaultNode) _symbol_d.value;
					final Symbol _symbol_c2 = _symbols[offset + 4];
					final ArrayList _list_c2 = (ArrayList) _symbol_c2.value;
					final JSCaseNode[] c2 = _list_c2 == null ? new JSCaseNode[0] : (JSCaseNode[]) _list_c2.toArray(new JSCaseNode[_list_c2.size()]);
					
			List<JSNode> nodes = new ArrayList<JSNode>();
			if (c1 != null) {
				for (JSNode statement : c1)
				{
					nodes.add(statement);
				}
			}
			nodes.add(d);
			if (c2 != null) {
				for (JSNode statement : c2)
				{
					nodes.add(statement);
				}
			}
			return new Symbol(nodes);
			}
			case 308: // CaseClauses = CaseClause
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 309: // CaseClauses = CaseClauses CaseClause
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 310: // CaseClause = CASE Expression.e COLON.c opt$StatementList.s
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol c = _symbols[offset + 3];
					final Symbol _symbol_s = _symbols[offset + 4];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final JSNode[] s = _list_s == null ? new JSNode[0] : (JSNode[]) _list_s.toArray(new JSNode[_list_s.size()]);
					
			if (s == null) {
				return new JSCaseNode(e, c);
			}
			return new JSCaseNode(e, c, s);
			}
			case 311: // DefaultClause = DEFAULT COLON.c opt$StatementList.s
			{
					final Symbol c = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final JSNode[] s = _list_s == null ? new JSNode[0] : (JSNode[]) _list_s.toArray(new JSNode[_list_s.size()]);
					
			if (s == null) {
				return new JSDefaultNode(c);
			}
			return new JSDefaultNode(c, s);
			}
			case 312: // LabelledStatement = Identifier.i COLON.c LabelledItem.s
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol c = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final JSNode s = (JSNode) _symbol_s.value;
					
			JSNode id = new JSIdentifierNode(i);
			id.setLocation(i.getStart(), i.getEnd());

			return new JSLabelledNode(id, c, s);
			}
			case 313: // LabelledStatement_NoIf = Identifier.i COLON.c LabelledItem_NoIf.s
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol c = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final JSNode s = (JSNode) _symbol_s.value;
					
			JSNode id = new JSIdentifierNode(i);
			id.setLocation(i.getStart(), i.getEnd());

			return new JSLabelledNode(id, c, s);
			}
			case 318: // ThrowStatement = THROW Expression.e SEMICOLON
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			JSNode node = new JSThrowNode(e);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 319: // TryStatement = TRY Block.b Catch.c
			{
					final Symbol _symbol_b = _symbols[offset + 2];
					final JSStatementsNode b = (JSStatementsNode) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 3];
					final JSCatchNode c = (JSCatchNode) _symbol_c.value;
					
			return new JSTryNode(b, c, new JSEmptyNode(c));
			}
			case 320: // TryStatement = TRY Block.b Finally.f
			{
					final Symbol _symbol_b = _symbols[offset + 2];
					final JSStatementsNode b = (JSStatementsNode) _symbol_b.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final JSFinallyNode f = (JSFinallyNode) _symbol_f.value;
					
			return new JSTryNode(b, new JSEmptyNode(b), f);
			}
			case 321: // TryStatement = TRY Block.b Catch.c Finally.f
			{
					final Symbol _symbol_b = _symbols[offset + 2];
					final JSStatementsNode b = (JSStatementsNode) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 3];
					final JSCatchNode c = (JSCatchNode) _symbol_c.value;
					final Symbol _symbol_f = _symbols[offset + 4];
					final JSFinallyNode f = (JSFinallyNode) _symbol_f.value;
					
			return new JSTryNode(b, c, f);
			}
			case 322: // Catch = CATCH LPAREN CatchParameter.p RPAREN Block.b
			{
					final Symbol _symbol_p = _symbols[offset + 3];
					final JSNode p = (JSNode) _symbol_p.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final JSStatementsNode b = (JSStatementsNode) _symbol_b.value;
					
			return new JSCatchNode(p, b);
			}
			case 323: // Finally = FINALLY Block.b
			{
					final Symbol _symbol_b = _symbols[offset + 2];
					final JSStatementsNode b = (JSStatementsNode) _symbol_b.value;
					
			return new JSFinallyNode(b);
			}
			case 324: // CatchParameter = Identifier.i
			{
					final Symbol i = _symbols[offset + 1];
					
			return new JSIdentifierNode(i);
			}
			case 327: // FunctionDeclaration = FUNCTION Identifier.ident LPAREN FormalParameters.params RPAREN LCURLY FunctionBody.body RCURLY
			{
					final Symbol ident = _symbols[offset + 2];
					final Symbol _symbol_params = _symbols[offset + 4];
					final JSParametersNode params = (JSParametersNode) _symbol_params.value;
					final Symbol _symbol_body = _symbols[offset + 7];
					final JSStatementsNode body = (JSStatementsNode) _symbol_body.value;
					
			return new JSFunctionNode(
				new JSIdentifierNode(ident),
				params,
				body
			);
			}
			case 330: // FunctionExpression = FUNCTION.f opt$Identifier.ident LPAREN FormalParameters.params RPAREN LCURLY FunctionBody.body RCURLY
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol ident = _symbols[offset + 2];
					final Symbol _symbol_params = _symbols[offset + 4];
					final JSParametersNode params = (JSParametersNode) _symbol_params.value;
					final Symbol _symbol_body = _symbols[offset + 7];
					final JSStatementsNode body = (JSStatementsNode) _symbol_body.value;
					
			if (ident != null) {
				return new JSFunctionNode(
					new JSIdentifierNode(ident),
					params,
					body
				);
			}
			return new JSFunctionNode(
				new JSEmptyNode(f),
				params,
				body
			);
			}
			case 332: // FormalParameters = FormalParameterList.params
			{
					final Symbol _symbol_params = _symbols[offset + 1];
					final ArrayList params = (ArrayList) _symbol_params.value;
					
			final JSNode[] p = params == null ? new JSNode[0] : (JSNode[]) params.toArray(new JSNode[params.size()]);
			return new JSParametersNode(p);
			}
			case 333: // FormalParameters = 
			{
					
			return new JSParametersNode();
			}
			case 334: // FormalParameterList = FunctionRestParameter.p
			{
					final Symbol p = _symbols[offset + 1];
					
			ArrayList lst = new ArrayList();
			lst.add(p);
			return new Symbol(lst);
			}
			case 336: // FormalParameterList = FormalsList.l COMMA FunctionRestParameter.p
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList _list_l = (ArrayList) _symbol_l.value;
					final JSNode[] l = _list_l == null ? new JSNode[0] : (JSNode[]) _list_l.toArray(new JSNode[_list_l.size()]);
					final Symbol p = _symbols[offset + 3];
					
			_list_l.add(p);
			return _symbol_l;
			}
			case 337: // FormalsList = FormalsList COMMA FormalParameter
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 338: // FormalsList = FormalParameter
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 342: // FunctionStatementList = StatementList.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final JSNode[] s = _list_s == null ? new JSNode[0] : (JSNode[]) _list_s.toArray(new JSNode[_list_s.size()]);
					
			return new JSStatementsNode(s);
			}
			case 343: // FunctionStatementList = 
			{
					
			return new JSStatementsNode();
			}
			case 350: // MethodDefinition = GET PropertyName.n LPAREN RPAREN LCURLY FunctionBody.body RCURLY
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final JSNode n = (JSNode) _symbol_n.value;
					final Symbol _symbol_body = _symbols[offset + 6];
					final JSStatementsNode body = (JSStatementsNode) _symbol_body.value;
					
			return new JSNameValuePairNode(n, body);
			}
			case 351: // MethodDefinition = SET PropertyName.n LPAREN PropertySetParameterList.p RPAREN LCURLY FunctionBody.body RCURLY
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final JSNode n = (JSNode) _symbol_n.value;
					final Symbol _symbol_p = _symbols[offset + 4];
					final JSNode p = (JSNode) _symbol_p.value;
					final Symbol _symbol_body = _symbols[offset + 7];
					final JSStatementsNode body = (JSStatementsNode) _symbol_body.value;
					
			JSParametersNode params = new JSParametersNode(p);
			params.setLocation(p.getStartingOffset(), p.getEndingOffset());
			return new JSNameValuePairNode(n, params, body);
			}
			case 368: // ClassElementList = ClassElement
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
			}
			case 369: // ClassElementList = ClassElementList ClassElement
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
			}
			case 375: // Script = opt$ScriptBody.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final JSNode[] s = _list_s == null ? new JSNode[0] : (JSNode[]) _list_s.toArray(new JSNode[_list_s.size()]);
					
			return new JSParseRootNode(s);
			}
			case 379: // Module = opt$ModuleBody.m
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final ArrayList _list_m = (ArrayList) _symbol_m.value;
					final JSNode[] m = _list_m == null ? new JSNode[0] : (JSNode[]) _list_m.toArray(new JSNode[_list_m.size()]);
					
			return new JSParseRootNode(m);
			}
			case 381: // ModuleItemList = ModuleItemList ModuleItem
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 382: // ModuleItemList = ModuleItem
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 399: // ImportsList = ImportsList COMMA ImportSpecifier
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
			}
			case 400: // ImportsList = ImportSpecifier
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
			}
			case 416: // ExportsList = ExportsList COMMA ExportSpecifier
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
			}
			case 417: // ExportsList = ExportSpecifier
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
			}
			case 65: // opt$Elision = 
			case 78: // opt$COMMA = 
			case 222: // opt$StatementList = 
			case 234: // opt$Initializer = 
			case 248: // opt$BindingRestElement = 
			case 270: // opt$Expression = 
			case 304: // opt$CaseClauses = 
			case 328: // opt$Identifier = 
			case 373: // opt$ScriptBody = 
			case 377: // opt$ModuleBody = 
			{
				return new Symbol(null);
			}
			case 0: // $goal = Module
			case 2: // Identifier = IDENTIFIER
			case 3: // Identifier = GET
			case 4: // Identifier = IMPLEMENTS
			case 5: // Identifier = INTERFACE
			case 6: // Identifier = OF
			case 7: // Identifier = PACKAGE
			case 8: // Identifier = PRIVATE
			case 9: // Identifier = PROTECTED
			case 10: // Identifier = PUBLIC
			case 11: // Identifier = SET
			case 12: // Identifier = STATIC
			case 13: // Identifier = TARGET
			case 14: // IdentifierName = Identifier
			case 15: // IdentifierName = AWAIT
			case 16: // IdentifierName = BREAK
			case 17: // IdentifierName = CASE
			case 18: // IdentifierName = CATCH
			case 19: // IdentifierName = CLASS
			case 20: // IdentifierName = CONST
			case 21: // IdentifierName = CONTINUE
			case 22: // IdentifierName = DEBUGGER
			case 23: // IdentifierName = DEFAULT
			case 24: // IdentifierName = DELETE
			case 25: // IdentifierName = DO
			case 26: // IdentifierName = ELSE
			case 27: // IdentifierName = ENUM
			case 28: // IdentifierName = EXPORT
			case 29: // IdentifierName = EXTENDS
			case 30: // IdentifierName = FINALLY
			case 31: // IdentifierName = FOR
			case 32: // IdentifierName = FUNCTION
			case 33: // IdentifierName = IF
			case 34: // IdentifierName = IMPORT
			case 35: // IdentifierName = INSTANCEOF
			case 36: // IdentifierName = IN
			case 37: // IdentifierName = NEW
			case 38: // IdentifierName = RETURN
			case 39: // IdentifierName = SUPER
			case 40: // IdentifierName = SWITCH
			case 41: // IdentifierName = THIS
			case 42: // IdentifierName = THROW
			case 43: // IdentifierName = TRY
			case 44: // IdentifierName = TYPEOF
			case 45: // IdentifierName = VAR
			case 46: // IdentifierName = VOID
			case 47: // IdentifierName = WHILE
			case 48: // IdentifierName = WITH
			case 49: // IdentifierName = BooleanLiteral
			case 50: // IdentifierName = NullLiteral
			case 55: // Literal = NullLiteral
			case 56: // Literal = BooleanLiteral
			case 57: // Literal = NumericLiteral
			case 58: // Literal = StringLiteral
			case 66: // opt$Elision = Elision
			case 79: // opt$COMMA = COMMA
			case 83: // PropertyDefinition = CoverInitializedName
			case 85: // PropertyDefinition = MethodDefinition
			case 86: // PropertyName = LiteralPropertyName
			case 87: // PropertyName = ComputedPropertyName
			case 89: // LiteralPropertyName = StringLiteral
			case 90: // LiteralPropertyName = NumericLiteral
			case 94: // TemplateLiteral = NoSubstitutionTemplate
			case 96: // TemplateSpans = TemplateTail
			case 104: // ArgumentListItem = SingleExpression
			case 106: // MultiplicativeOperator = STAR
			case 107: // MultiplicativeOperator = FORWARD_SLASH
			case 108: // MultiplicativeOperator = PERCENT
			case 109: // AssignmentOperator = STAR_EQUAL
			case 110: // AssignmentOperator = FORWARD_SLASH_EQUAL
			case 111: // AssignmentOperator = PERCENT_EQUAL
			case 112: // AssignmentOperator = PLUS_EQUAL
			case 113: // AssignmentOperator = MINUS_EQUAL
			case 114: // AssignmentOperator = LESS_LESS_EQUAL
			case 115: // AssignmentOperator = GREATER_GREATER_EQUAL
			case 116: // AssignmentOperator = GREATER_GREATER_GREATER_EQUAL
			case 117: // AssignmentOperator = AMPERSAND_EQUAL
			case 118: // AssignmentOperator = CARET_EQUAL
			case 119: // AssignmentOperator = PIPE_EQUAL
			case 120: // Expression = SingleExpression
			case 122: // SingleExpression = FunctionExpression
			case 123: // SingleExpression = GeneratorExpression
			case 124: // SingleExpression = RegularExpressionLiteral
			case 125: // SingleExpression = TemplateLiteral
			case 126: // SingleExpression = CoverParenthesizedExpressionAndArrowParameterList
			case 128: // SingleExpression = SingleExpression.l TemplateLiteral
			case 141: // SingleExpression = YieldExpression
			case 142: // SingleExpression = ArrowFunction
			case 147: // SingleExpression = Literal
			case 148: // SingleExpression = ArrayLiteral
			case 149: // SingleExpression = ObjectLiteral
			case 150: // PostUnaryOperator = PLUS_PLUS
			case 151: // PostUnaryOperator = MINUS_MINUS
			case 152: // PreUnaryOperator = PostUnaryOperator
			case 153: // PreUnaryOperator = DELETE
			case 154: // PreUnaryOperator = VOID
			case 155: // PreUnaryOperator = TYPEOF
			case 156: // PreUnaryOperator = PLUS
			case 157: // PreUnaryOperator = MINUS
			case 158: // PreUnaryOperator = TILDE
			case 159: // PreUnaryOperator = EXCLAMATION
			case 160: // BinaryArithmeticOperator = MultiplicativeOperator
			case 161: // BinaryArithmeticOperator = PIPE
			case 162: // BinaryArithmeticOperator = CARET
			case 163: // BinaryArithmeticOperator = AMPERSAND
			case 164: // BinaryArithmeticOperator = PLUS
			case 165: // BinaryArithmeticOperator = MINUS
			case 166: // BinaryArithmeticOperator = LESS_LESS
			case 167: // BinaryArithmeticOperator = GREATER_GREATER
			case 168: // BinaryArithmeticOperator = GREATER_GREATER_GREATER
			case 169: // BinaryBooleanOperator = PIPE_PIPE
			case 170: // BinaryBooleanOperator = AMPERSAND_AMPERSAND
			case 171: // BinaryBooleanOperator = EXCLAMATION_EQUAL_EQUAL
			case 172: // BinaryBooleanOperator = EQUAL_EQUAL_EQUAL
			case 173: // BinaryBooleanOperator = EXCLAMATION_EQUAL
			case 174: // BinaryBooleanOperator = EQUAL_EQUAL
			case 175: // BinaryBooleanOperator = IN
			case 176: // BinaryBooleanOperator = INSTANCEOF
			case 177: // BinaryBooleanOperator = LESS
			case 178: // BinaryBooleanOperator = GREATER
			case 179: // BinaryBooleanOperator = LESS_EQUAL
			case 180: // BinaryBooleanOperator = GREATER_EQUAL
			case 181: // Statement = BlockStatement
			case 182: // Statement = VariableStatement
			case 183: // Statement = EmptyStatement
			case 184: // Statement = ExpressionStatement
			case 185: // Statement = IfStatement
			case 186: // Statement = BreakableStatement
			case 187: // Statement = ContinueStatement
			case 188: // Statement = BreakStatement
			case 189: // Statement = ReturnStatement
			case 190: // Statement = WithStatement
			case 191: // Statement = LabelledStatement
			case 192: // Statement = ThrowStatement
			case 193: // Statement = TryStatement
			case 194: // Statement = DebuggerStatement
			case 196: // Statement_NoIf = BlockStatement
			case 197: // Statement_NoIf = VariableStatement
			case 198: // Statement_NoIf = EmptyStatement
			case 199: // Statement_NoIf = ExpressionStatement
			case 200: // Statement_NoIf = IfStatement_NoIf
			case 201: // Statement_NoIf = BreakableStatement_NoIf
			case 202: // Statement_NoIf = ContinueStatement
			case 203: // Statement_NoIf = BreakStatement
			case 204: // Statement_NoIf = ReturnStatement
			case 205: // Statement_NoIf = WithStatement_NoIf
			case 206: // Statement_NoIf = LabelledStatement_NoIf
			case 207: // Statement_NoIf = ThrowStatement
			case 208: // Statement_NoIf = TryStatement
			case 209: // Statement_NoIf = DebuggerStatement
			case 212: // Declaration = HoistableDeclaration
			case 213: // Declaration = ClassDeclaration
			case 214: // Declaration = LexicalDeclaration
			case 215: // HoistableDeclaration = FunctionDeclaration
			case 216: // HoistableDeclaration = GeneratorDeclaration
			case 217: // BreakableStatement = IterationStatement
			case 218: // BreakableStatement = SwitchStatement
			case 219: // BreakableStatement_NoIf = IterationStatement_NoIf
			case 220: // BreakableStatement_NoIf = SwitchStatement
			case 221: // BlockStatement = Block
			case 223: // opt$StatementList = StatementList
			case 227: // StatementListItem = Statement
			case 228: // StatementListItem = Declaration
			case 230: // LetOrConst = LET
			case 231: // LetOrConst = CONST
			case 235: // opt$Initializer = Initializer
			case 243: // BindingPattern = ObjectBindingPattern
			case 244: // BindingPattern = ArrayBindingPattern
			case 249: // opt$BindingRestElement = BindingRestElement
			case 258: // BindingProperty = SingleNameBinding
			case 260: // BindingElement = SingleNameBinding
			case 271: // opt$Expression = Expression
			case 294: // ForBinding = BindingPattern
			case 305: // opt$CaseClauses = CaseClauses
			case 314: // LabelledItem = Statement
			case 315: // LabelledItem = FunctionDeclaration
			case 316: // LabelledItem_NoIf = Statement_NoIf
			case 317: // LabelledItem_NoIf = FunctionDeclaration
			case 325: // CatchParameter = BindingPattern
			case 329: // opt$Identifier = Identifier
			case 331: // StrictFormalParameters = FormalParameters
			case 335: // FormalParameterList = FormalsList.l
			case 339: // FunctionRestParameter = BindingRestElement
			case 340: // FormalParameter = BindingElement
			case 341: // FunctionBody = FunctionStatementList
			case 345: // ArrowParameters = Identifier
			case 346: // ArrowParameters = CoverParenthesizedExpressionAndArrowParameterList
			case 347: // ConciseBody = SingleExpression
			case 349: // MethodDefinition = GeneratorMethod
			case 352: // PropertySetParameterList = FormalParameter
			case 356: // GeneratorBody = FunctionBody
			case 357: // YieldExpression = YIELD
			case 367: // ClassBody = ClassElementList
			case 370: // ClassElement = MethodDefinition
			case 372: // ClassElement = SEMICOLON
			case 374: // opt$ScriptBody = ScriptBody
			case 376: // ScriptBody = StatementList
			case 378: // opt$ModuleBody = ModuleBody
			case 380: // ModuleBody = ModuleItemList
			case 383: // ModuleItem = ImportDeclaration
			case 384: // ModuleItem = ExportDeclaration
			case 385: // ModuleItem = StatementListItem
			case 388: // ImportClause = ImportedDefaultBinding
			case 389: // ImportClause = NameSpaceImport
			case 390: // ImportClause = NamedImports
			case 393: // ImportedDefaultBinding = ImportedBinding
			case 402: // ImportSpecifier = ImportedBinding
			case 403: // ModuleSpecifier = STRING
			case 404: // ImportedBinding = Identifier
			case 419: // ExportSpecifier = IdentifierName
			case 420: // NoSubstitutionTemplate = NO_SUB_TEMPLATE
			case 421: // TemplateHead = TEMPLATE_HEAD
			case 422: // TemplateMiddle = TEMPLATE_MIDDLE
			case 423: // TemplateTail = TEMPLATE_TAIL
			{
				return _symbols[offset + 1];
			}
			case 1: // $goal = $Script Script
			case 52: // CoverParenthesizedExpressionAndArrowParameterList = LPAREN RPAREN
			case 71: // ElementList = opt$Elision.n SpreadElement.e
			case 76: // SpreadElement = DOT_DOT_DOT SingleExpression
			case 97: // TemplateSpans = TemplateMiddleList TemplateTail
			case 98: // TemplateMiddleList = TemplateMiddle Expression
			case 105: // ArgumentListItem = DOT_DOT_DOT SingleExpression
			case 134: // SingleExpression = SUPER Arguments
			case 237: // LexicalBinding = BindingPattern Initializer
			case 242: // VariableDeclaration = BindingPattern Initializer
			case 257: // BindingElisionElement = opt$Elision BindingElement
			case 261: // BindingElement = BindingPattern opt$Initializer
			case 263: // BindingRestElement = DOT_DOT_DOT Identifier
			case 292: // ForDeclaration = LetOrConst ForBinding
			case 306: // CaseBlock = LCURLY opt$CaseClauses.c RCURLY
			case 326: // DebuggerStatement = DEBUGGER SEMICOLON
			case 348: // ConciseBody = LCURLY FunctionBody.body RCURLY
			case 358: // YieldExpression = YIELD SingleExpression
			case 365: // ClassTail = LCURLY RCURLY
			case 366: // ClassHeritage = EXTENDS SingleExpression
			case 371: // ClassElement = STATIC MethodDefinition
			case 395: // NamedImports = LCURLY RCURLY
			case 398: // FromClause = FROM ModuleSpecifier
			case 408: // ExportDeclaration = EXPORT VariableStatement
			case 409: // ExportDeclaration = EXPORT Declaration
			case 413: // ExportClause = LCURLY RCURLY
			{
				return _symbols[offset + 2];
			}
			case 91: // ComputedPropertyName = LBRACKET SingleExpression RBRACKET
			case 95: // TemplateLiteral = TemplateHead Expression TemplateSpans
			case 99: // TemplateMiddleList = TemplateMiddleList TemplateMiddle Expression
			case 130: // SingleExpression = SUPER DOT IdentifierName
			case 131: // SingleExpression = NEW DOT TARGET
			case 344: // ArrowFunction = ArrowParameters ARROW ConciseBody
			case 359: // YieldExpression = YIELD STAR SingleExpression
			case 360: // ClassDeclaration = CLASS Identifier ClassTail
			case 361: // ClassExpression = CLASS opt$Identifier ClassTail
			case 363: // ClassTail = LCURLY ClassBody RCURLY
			case 364: // ClassTail = ClassHeritage LCURLY RCURLY
			case 387: // ImportDeclaration = IMPORT ModuleSpecifier SEMICOLON
			case 391: // ImportClause = ImportedDefaultBinding COMMA NameSpaceImport
			case 392: // ImportClause = ImportedDefaultBinding COMMA NamedImports
			case 394: // NameSpaceImport = STAR AS ImportedBinding
			case 396: // NamedImports = LCURLY ImportsList RCURLY
			case 401: // ImportSpecifier = IdentifierName AS ImportedBinding
			case 407: // ExportDeclaration = EXPORT ExportClause SEMICOLON
			case 410: // ExportDeclaration = EXPORT DEFAULT HoistableDeclaration
			case 411: // ExportDeclaration = EXPORT DEFAULT ClassExpression
			case 414: // ExportClause = LCURLY ExportsList RCURLY
			case 418: // ExportSpecifier = IdentifierName AS IdentifierName
			{
				return _symbols[offset + 3];
			}
			case 53: // CoverParenthesizedExpressionAndArrowParameterList = LPAREN DOT_DOT_DOT Identifier RPAREN
			case 73: // ElementList = ElementList.l COMMA opt$Elision.n SpreadElement.e
			case 129: // SingleExpression = SUPER LBRACKET Expression RBRACKET
			case 362: // ClassTail = ClassHeritage LCURLY ClassBody RCURLY
			case 386: // ImportDeclaration = IMPORT ImportClause FromClause SEMICOLON
			case 397: // NamedImports = LCURLY ImportsList COMMA RCURLY
			case 405: // ExportDeclaration = EXPORT STAR FromClause SEMICOLON
			case 406: // ExportDeclaration = EXPORT ExportClause FromClause SEMICOLON
			case 415: // ExportClause = LCURLY ExportsList COMMA RCURLY
			{
				return _symbols[offset + 4];
			}
			case 412: // ExportDeclaration = EXPORT DEFAULT Identifier SingleExpression SEMICOLON
			{
				return _symbols[offset + 5];
			}
			case 54: // CoverParenthesizedExpressionAndArrowParameterList = LPAREN Expression COMMA DOT_DOT_DOT Identifier RPAREN
			{
				return _symbols[offset + 6];
			}
			case 353: // GeneratorMethod = STAR PropertyName LPAREN StrictFormalParameters RPAREN LCURLY GeneratorBody RCURLY
			{
				return _symbols[offset + 8];
			}
			case 354: // GeneratorDeclaration = FUNCTION STAR Identifier LPAREN FormalParameters RPAREN LCURLY GeneratorBody RCURLY
			case 355: // GeneratorExpression = FUNCTION STAR opt$Identifier LPAREN FormalParameters RPAREN LCURLY GeneratorBody RCURLY
			{
				return _symbols[offset + 9];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
