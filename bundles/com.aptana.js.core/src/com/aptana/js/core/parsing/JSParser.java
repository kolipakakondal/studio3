package com.aptana.js.core.parsing;

import com.aptana.parsing.IRecoveryStrategy;
import com.aptana.parsing.ast.IParseNode;
import com.aptana.core.build.IProblem;
import com.aptana.js.core.JSCorePlugin;
import com.aptana.parsing.WorkingParseResult;
import com.aptana.js.core.preferences.IPreferenceConstants;
import java.io.IOException;
import com.aptana.parsing.ast.ParseError;
import java.util.ArrayList;
import java.util.List;
import com.aptana.parsing.IParser;
import com.aptana.parsing.ParseResult;
import org.eclipse.core.runtime.Platform;
import com.aptana.js.core.IJSConstants;
import com.aptana.parsing.IParseState;
import beaver.*;
import com.aptana.js.core.parsing.ast.*;
import com.aptana.parsing.util.ParseUtil;
import com.aptana.parsing.ast.IParseError;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "JS.grammar".
 */
@SuppressWarnings({ "unchecked", "rawtypes" })
public class JSParser extends Parser implements IParser {
	static public class AltGoals {
		static public final short Script = 111;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjNGTy5CNtVpERUaS8e09If4g2z1982A68NMmWDgHOVugY2HOiY88eLXInzuAeg2We0g8" +
		"WlOaeNQGfNHH4YgAuy$$kxDpjxbqskTiSX$Y$pUVjp4vvxplllMcxUnkYa$lHM1hFMh7pQ0" +
		"ozI#$H#$G1VKZZw6EQpJhnpTI2Mj95T37$bM$bk$aUlfS#fGdq2V#P7#1$iaVOm#nHzXXxY" +
		"2wZI#XIsiB$u0VvBtmdtyN$uh$pxNmB$utlupluVjQRTwNdw76wYfwbjNmRPHkIwHtwA5Io" +
		"4EmATZCDOLLeDBrDJz8mje2Ue4Ve6Hf93z1G6i5$f6xyRtw8R#8$qMHQHPDu2dr7IsaPBQS" +
		"Lj99kuwbi4VLcYzat#dtwOzIG6b4hsPOCgadbA9qzmPQmFMmZsq1#Aa#PL84gKYKwXewbuw" +
		"WoLQ6gT3pjfjzegnXFzz7$#2gwdfr6DTZ5j92giTDfAcj1rSd7Xh8AD9clfqd0CP4c2Pqsq" +
		"#Vq1T$0L$8Lj8OsiPRKZ#RgLpBExcD3s22QvzPkVhriz$Tk#NGrgqpTIAT$I30gjTrNeTqt" +
		"q##iEL$3FBIRRQSXDCEmWBtTB9lT8TizI4lMUxaYXUym5l0TDfsTmGxo9FhMz1tgJZtemd3" +
		"VeHFOw#njzW9jPnNPEDf3##aWgyTEOUsqzln66a03eBrfscbi8R#IQdFID2s9ldJ3e36fpJ" +
		"fiWPP5N4lXFz2T6d6Xjuv6Yv0v49BNQVdGPeFejKYpsEtGv3egDBN82gKM1q6RqAA#abNGL" +
		"uezh8hXBOOsADNqesWmijl47c1heDz79w9NHOsHhqMjdU2GhImzG6Bim7iQ6Fd$30zds#3X" +
		"dr4IfL0oRTOgQfNOVDMhDaM5TQwgPPwZzyghWV8Q$ay0A$jHOardnqglh06iGu3VyDfXx7v" +
		"eVZDyk0#mJcP$e0LHOUMLouXrA1rYlTcflAhIwrg5zLC3Art3Ad1YhTcVR0gy36C3RHOx#6" +
		"LiFjlE$qS3QPERPuCdF9krbxtd9hgMzM9dyMvwttZrHhgNRg1wB0l#batrsK9s9kl3#c9yx" +
		"w7Vg$y4pxu7BNN3RlJ6kbfAL7tm01z1chA21$#cRFqzbeNpVNR$rYgpLwL$BtVw36ARsPTi" +
		"AltenRyT7kC1Atmccxt5guRqnKciXlJlyS2wW9tFfh2p0ZwZ7SScil9UiFBZo#RVbCrxO7R" +
		"CrcgelfWkPyOPR8RqxqLIhni2UaN9pLexsiZgc2DSlFNAdgIVE0NqoYjAlUv4JpF6uKTO1V" +
		"OBFuVzmxEvtzIhFWmQplNa0zlOI3QgB7fb9x9BqSeTTgpqA#ijVU1CgTUrScqqW5t6ss6Cs" +
		"qlxM0zZXgG$lEkLRVQWrwrO9NPXOm9ObRzcqP$I1mPeoVm6kZKK3ttZn4EBwMpgJUVGkNGx" +
		"BQ6lgJzxaCwZczW#iPptOpwnKQndWwDfbyRPHwmSUassN2LuiK4Bbi5hyPEKRtDptkRtInj" +
		"aiWfY5TewX5MITgZ3kl3hbHPhidEZcX7J0rxD6x3E7YpG54XRiWFyL8Mqbe6KFygVbqZFWR" +
		"V0B$Whh25hp1hnJrWNN9iI1qI7LAl2QhEwqCn9l3ERvWKfwhRaO$b44wbsZ4Gwao#o8zKgi" +
		"BCDf8PEJPpwpLX$DUMFHw7J7Bs7MPUFvzNvBLIJ3s37MqXv4R$LGCe7yZludGPIFeZVmmVp" +
		"Usat7qvRDHzhmzhI#IoFFycMinLi9Ll5LhFlsHhs0rlBrh7rV2I$ZT$Ex#9tywSYd7VJM8E" +
		"opRkiAcR#Jl2vVEbpQyLMre4LG4P7TZ8xbNLb5x3k$0dzwdYj0pXZ5xABg07RplhHGBRGTI" +
		"LUMQx46qY#Wza0$KUS5#XNn76zCeJT9UUXUzXBMAz4qpiNi9VPQ#mDDeQzgzNsuFDZsGSOY" +
		"IQmJzHOlawE8rFPPt9ypAQqk6d179sswqFPJsookxM0pLXT6bm$PpFPR3Q7pSF#EquesHRz" +
		"LhQK$QtVpvFrnwErbVwe$h3#8A$4Z#N7UTW7LU7LU1sCbVNKNDP0phidybP7q5Q$ynntM#b" +
		"t16n5G$YvXeVpy#Deg$ty0jvT7w4FvPVoox4hn#Z4#sWTz6Vqf$crSYVWXdja754E5iU8Ie" +
		"OkQQ2ewAvBKI6WIv4foeiCKKxuuuUIxXK#aSw7w0T5caYDrkz5YaZc3#ZVw7$pXwFtU$rz$" +
		"NNzPVqL$P0QevwHy$Ap$8KZu$Vy9Nse$fK#tTrM$4t3LhmlVvsFvcFqQVm3lZX#jk8B#3X#" +
		"1P#AtcdiUnVgN#gVwvFub$eN#bI#J9$yx$1xVOh#6SQoZUYTlUYF4ln#ZA5ByRROINl5Dfu" +
		"iLcAL5Z#$DqUwV7seM2Q#WovNYc$4OitdTbTQxusv#06zZxvIImFAKVGWFKylqijA$gFq6h" +
		"rXoDVIjNAiakRNk#gdwzteTNgJdgB7w6bwYrwYX#X#Ue5UeOVfLMfWtfKM7zEpMdaQhbyWl" +
		"dLTnnnhQ4e$JpzNgsRSbHPBd7UbtJ1hrR7#UC0OdVLpj5hkcCLIiKU$KE#k#RI6McDtpDf9" +
		"rfrqhGaDTyMRQ#3LyhG2hRFMXTKqC6ljmp77vGxkgMmcoKFhIEJkZSWprefcoROoYBitaZe" +
		"YGwcE8uWogftH0ZjeSsV42oFV6SbgnVevQwQO$XB1piZ0$O0ilGNasYFWvpZqGiNPlHSR1t" +
		"e4kvAUHSorHy1AJhkXH#0SMOyWhQxPYsLDLyn1tgQLIiTyRIcOGttDwCKdX3mFYy83zCUqE" +
		"cNr0ArcaC522ZluCCi3elBDxQWymucCTaM1h1GDYjNyGM$85287CdPSx921vsDbGURK6HiT" +
		"2sH1dg$64Dc7CKNsJkoGyVenHVPH394rZ1mP#zQeL$mTAyNpqnWYQn9JdKsE8R8sCKKsBOR" +
		"8ycEAR5OCaNMCAR9vCKHsIfJhan8F$dKCaPqHKsJV7hvxoln5$XeVnU$Z3uMi9UDqx$fV9g" +
		"VwOPD3mPMjSPI#IZGFzrLYDibL8ixcAZ5mbDO3erdP7i2wsC1ihbXBn2nsHu2PN32RXsFtu" +
		"ZYYmVpVzi#4d8ISX9n$evniERvdo$4gEmRZUqbZfVsTbz1HCmvZPRpM34U9d8ZN3F#rjTPH" +
		"Of#4d8ISX9nev1Y78QKjvRhjLOfPfRlFPMUOSvbMLSrbPz9Pr9fog0tbKJjgJmNKWJfI9#f" +
		"Cfz2fT1gTJasYdiiE4sRZ#T$HXbbh4p7cwDSCHrxFSS0i7Ym5yyboRTO5cBCZmSoUeVpYCN" +
		"ju9pTmoFSvx6ylblhkgZfOBrQjz3jryYYxVScqBxlHj2$hBn7qONs3QAewMR4Ruc3VEoEsR" +
		"wHztyM#CSHynr68#QwZ4FCjyS8SLTzt7kQxNBkYUD#qZBBiJpKFkwmNuoXhT1nbVHW$MVRd" +
		"beTTLiCuoceIHrbjuYWhFuwoEiPHrYbnb7L676Kz$UyS3zttZhJQkNUak#chalUE#Y9UaxK" +
		"eXQCys4AJ8nD1ZiJE1LaSRKT9RyHvGlakU3O5jNJeRf1DuZacIY9#YVmDKU1mVHytrYZPLt" +
		"PeOeFzYdyNIqdopQjOydCvcCPIs8wOwYWbfhZ$SdrBl3yaEGxX$cq53vB5BsuwayVbCMrbR" +
		"3LMqk7#rgkdNXiF7pME64kAYmxa#1FJti2lYvU6ZbRB9d0VrRXBw4cnbUJeIIw$x11xqNy7" +
		"nrHgrv8iupp4Yd$hY9VWzP$dTUM$55U2Lu9NWbU2Lu9NWbU2Lu9NWbU2Lu9NWbU2b$7bWKX" +
		"uUVXQ7szhVAqlS5#26p#KBe43ry31B5c31XiS#FU8j#1dkh$T8R$DyuudRDFjsDGThiU2M3" +
		"ivSxIwECdV#0DRyE1JtB7f8uqdCVmDJryvt1ME3MtzIY8vWS$tmbDhPV3KwdYfItV9howU1" +
		"WoxjNfQItPwwSy5jUFPRpIdzEU2x6TdA$bIxmZ3xuKvdmi2DJ7RKmxM1DOiqRU29S#Lv$Uy" +
		"OmluLYIzm4JDQx131WUcXxJ9U9eflw$0hx6UPhBto#1fPTPuD7sx#5R9DlGoISRbBmfvxKZ" +
		"UL6I$bi6hRqHzW$fhfx3#yijDjhSJxTXu9YylgOQ55WWhW39uElFpSjp7qqBhyRfbmoOb1T" +
		"#Q34zHKe1BQRTN8CN4XdCwEm5dYOsVxS3MCZPzhJXKh5kO9cgOEDczHC6lAbD0XnBdh01EX" +
		"AszOzEQXSfcnJx$OaE3sf8sLT$t8$bzF#EehZLdrok$DBx#6sZ9MsMmwUDkDhJXkihKgTHM" +
		"VmERlLH0M$mOKrli5dQhaQB9aO2$NJQRigBYD1M2hrSGIw0lXDdKNYfOsjCOfR3LKqpg1xH" +
		"Md4tPZMoeVCEvl#mBIckyQKWfmwPtirkbJMifR1#MmQR$OtU6uoj9W$PLH3W#nm5y$FDOpe" +
		"cb7NPiMkLIIt$X2TiLiPbt8Zsq1bHKXl6aldPYa5D62L9IjKmLlQFO0dtZQKUQ4bTfq#CgR" +
		"QOdQRV4qUlco$FFSTNAtvxMW4dnxOiO7O#9i5noN57LZwkqL#8gxSsuIliuhjAypK1UfMsA" +
		"gxIzSPtvi#8gBI#kqaxsT9VefdYFZNneXELkZYkgH#8gxRcuIdivhj8cn5NQZBXAMnWpQH7" +
		"ywe2l3h#xQ1p5$#eWiaEiAUFkkUHtg4CFJ#krEAzliZoFW2TvhjdOSyscdciszropg#UQ5t" +
		"YksTDppLwUQzxekQRdVHTBzLppGSyrd$9SysdFDP$rNFDvppM$zbppEyyrbtcjoHjvhbdWk" +
		"UPfdcjUvBdcLPvhVkQvvXpFDR$nN5ENDQtVvaTp55$B#6s#SNIHvsOH$ZRVMOiYh5KC0XRw" +
		"HSj8aJiGiESYGy0RUqFEsrD9N#gFtXvRtDl5S#Nl5hhe$QB0ro4c5edWgI6$k7ZS$7GJ0Uk" +
		"b4FmUkIU9dwEsnzLs5AK$6mgYD9xuXQ7d5GmKF9rVI5tKaxJ8K4nIMbyV9VhP53zl#afvKs" +
		"4K#ER6hdyNVuG$vN8UVCbXG13sh4bhhL9A7HdPvH4ZG2tMy$1fpd54Cg97WJl6#axWJk1Eu" +
		"3wQS1T$U4FWDh#La5xysaEhWldj1ymOwaq9BIU8R8jsijQ9TzNAqG#OtqBUf73ylwCJhEPe" +
		"npXd7oqxMACPi$y7dkkBUpk13JLB6ld6$t$IMbYrSLh3XhAMrC#SCUnllwWroXhMtyXNl8p" +
		"yUlGzOYDuyu2Cm5j9EAwMv#lO9NADKa##lt8XRoxVNp7UvRWyWD2g7Mu#VfRnhWG$Zuq8IL" +
		"VlJt2f6oaZ#BoUlnUCVKoCE6cKHCcKGgcKHkda8p#LempNhwfKe#fKWsf2wxMeDjMXki1Pd" +
		"qwa1fH5sTIGJg96r1XUqXJxZURILrl1enR0emoVDRng2Vogo5KoISc5yBm1T0jTW7rKTxgG" +
		"UXZlvSgtRYz3Nf7CknMxgDjf8Dr1Tz9TT3SDedjeCDrBzz4G6ahtqp1wWFh2bz#HNcUqvN4" +
		"QGK$GapIIdg9Hz3GzGy$IS$GylK0lqalqChr2hz9hz3gzGM$IM$BjrZoQ27$V30yslVPoUF" +
		"77z0imV4AV8kypXS0y4qsZl#Xlca7ziPERJNDeBiqZmwUNqYBiyLQ0brkxDybshtVDtnbLk" +
		"mbIPy4Yit6Uww7T6P2MAQNPsrqUxJ3QlGBjfhZvpaH8pSVV2jZXT$ZE1IZTY$wWFs475mmi" +
		"HMB8Dto7bOFlzAIUh0Aho2f5fSLy#PT11w3DFXwq2AcedG4afXQNIYskW3ODBUP1Y$dmymB" +
		"fBOOsfYb4qM0yXFfzyDSNVQp80yPUg6MqhaXXp9SOZRvcO2mCUlWibi7AiqnWt4lxuE5chv" +
		"eJ5TQrgfPvzj8RYu1lIn3hB8br9l07i1OYFu0c0rWpePSP2bTyiKw4bou0RLHOboYisoNMT" +
		"S3Q2sF3BFeDY8snOHhik0DOpPutnxLtBP2UhKj$MGAD5E9wRHnxOo$W78jsz8Kknw4t5c9k" +
		"dm1K5o2b9poR0vKR5cCadu$U68qTiY3lPcK5B$vT11tDnBclmxyBbS$C2l6PV6c7RXxzs#u" +
		"nNh1Eb7rnOqXVtAvccnnWpO7F$0QB1dncELhd3MkFClft4InkzaSJwqo9DLDXDVjYJX1D7h" +
		"3c0xUtlXWBlUR9aSwEDSUcrtpP5tE2Uir3p9jUiygiropy5Q7Vsh7ceeTPUbqYqHXpKmwm5" +
		"gBy37bLM0QzzlIar$90a174cg$6k2o9DL$gDHey3z9mUeWUfaVeKNeCY0ha$6dCaD7n#Hsr" +
		"ScGDOvNWnGR6g9g5SSmvR#S4vsqJKOQompIitamjPa1QD4Xd1hswBVte0UbiI9iBEmIGvYZ" +
		"FDf4kanOml6GrTY9hfBVaAudvKI8jZxyysO#y8Yq2KakdROf5cg#G6ZerSUP1frbH8SsWtg" +
		"gkDwIzWQayLaHvG7ebNOMTsZLqBVsFhiEkiH$TG3VI99fCK#XpcafVn6tUtIDd$aAqnj334" +
		"dZWnLWlbCTr7kePMifXMbnNvOO$z97zCnFh03UvXL9k7yatNww8ZLLvFDShXP1fzjE6ShqI" +
		"kITrbxwN8S$BFNXIbZ4wCeuMcJu$KVfyD$f7#dmHV3vUMWYCJddWcbU2jRf9kGRNZN8CDMp" +
		"SFOwsoiFgdkDipCNHsYf7$fcelUmj2e3D62jDM$MHjbgWvh8ZPQkS4coL4xHLO2RAYQkj3D" +
		"$80HbZJtk9PWGyF4Uc6Ji1ToJnGvcFbLEkqcLk2RhC3UeoD$WNJrq6KEPAbD7vlOKumuFVM" +
		"xLDlsye$JxZYFfzRecsob9t23Fa#9ehrnJnirLRo1mdPrnZtzjUwIudUFvt#Bs19j$ecom9" +
		"cdBNPO6KQwomZJkkiq15SKHfMdo477iBW39BXhrBk3Tit4iZjEmde7INduLp1XsKEwdU9SZ" +
		"lOxihdGNvlI7TJVOLikszyRTEtfKk2BahxLOlBtWdjJTuk6CkG6vl#VSJ$jmnPuLWTfExJk" +
		"BD0zT2sLSCp1CZn1nhEqE#a0ST0BbYHXxacYMPNvQFkpSATKI6KfKzaYYZcYiSgAEUAsGjL" +
		"wt8t0XsHhASr1zbWTmrqaQMoLESNJKYSrMFACbkq9F3RaQFm3cY7e5ogXVBcgwOWxpDaQtC" +
		"c4DzhTXU78q7vD3oCdl0$c3zoqNOuV20g7Rj0Q$mXgmq3M9yzOXC8Ufrk91vrrc8vcE8hAp" +
		"MJ20x0iZwo7h5th5Aw2o1xB#FJ9Hw72N8uhMMJCY9gHnfHsiDK#egKPLpbrDahX9nbgl4O8" +
		"rIUc0qArlvh34pk68j4JCLb8vPvXQ3MTLpx5uSET5W$e$vJK9EGav2pb4WnnYFCusplETJv" +
		"l6zfB7IyMv6oAYP62iJSX9o4d8ISX9oohHNKLBSzYh5hDBTvRG9kQCT#DtGoTGb#DkXC#Jl" +
		"Yywchl9tx#T5EvSbC7l17FsQuVy7PldqgGJCG6nWReU$eiXyWyvtmHprExb1Z9xlD47c#wN" +
		"VgPCbosnVcMleQgooxpYPCfuc1Elk2U4r$TzatqZxlgjz4vWJc6FGzqCmHdzdFY4h8IiXAo" +
		"4h8Uk$BIlMUyV2aZagdEr3EHhOGK6EZbR5$8quy9mDckkGqiiMNsQY1CdV40NJNN7476KR1" +
		"xO2nrLEJ2LTNbAxekSdN0xv7d#CaSVOBzouzGnzEws4TtkzI2ueNcDALfkOoegfnah47I$h" +
		"nD173qFlYfCEOgxlDd7JqD5gsGJkenXtYJqfjhXjFQb4gUxVyubn$mspKsndimIl1Ay4hmI" +
		"l1Ay4hmIl1Ay4hmIl1Ay4hmIl1Ay4h$y$l3n$hIzuNw8GL0e7LN9CW0FYnfTdND$kaEtuik" +
		"pO0dUuWh5j8JaAku7Dbbe2DkZOU18JCsp6amDvdaZRol3bnELbgFi#fA#Y$UehgQKy5sJfz" +
		"2liMEfpGKOXhVmgTXeBVIuehUXuBWY49VfMiEJZybm6QmPyAv9UOAAszm97cvO9zNq5#zFC" +
		"Cc4xGdqxp5g59iduAjMg2DvKXATvR$jOr3Te7BK16LzkihsTQCT6q#6R1esnqEAyq21QJD#" +
		"0lgNlmkgLnIvZ5O$WMvFXAUeQk9Hs0$gRRcB36TY4CB6PAR70vk1J3AgGRYtCaLFgp#OhAY" +
		"SCPndrzaIOxB7X5fLZQK1RqgRcTyuGOeIJryPtpkOflrn4NyV4fhlTR6WTZ2cVDBGrJkhD$" +
		"iPiYBO2jcU#MDYKjXQdgH2z5Tfj6aXnsjHUAYPwS#qB3WbZQQBig#DaNr1Qe$aXfUOftHfV" +
		"T5uP0soxQMlfLdKW6EEuckzM3dahOxkAAFrmh732R1XM#eZEEn6tQRanCdh6kPVs1JaTT9V" +
		"2KbbQk0vj#SdnjMD2sf7pEci#JcWb76U4vLOTBTfBI4j8IqZxhqfBZ8r7ZwqIqluBqYBwrK" +
		"4nTnTbUh6$EeYm1GLbt3ttAat2uT7NuPQMg9cecQYPg9cecQWPqvh1t#P7DPCLMyluRRuCs" +
		"ybpGMI$pNVMGXXPhM8GK4zlo3tYpl68dBclhjmqMsABiafgb$o#IplpI$s7kLqE114zDIpl" +
		"WbiXW5UR5icAt9ECt$v5YTk18lAd2FBvHHXwMYXH64yZswadVb5fdNvEU9DR$tP1NCeJaiE" +
		"1e9XdOUgtcwMFZCQpfYZyUSFXqvm3OGGZUZIuOwll1Eu4xWJkemctIsiyhfXSxaL5cMwiEE" +
		"J$goqChfNB1v5boNjPRQWMSlF2tgIm$RyZusiNjlOuPX$hLwB6VtQpfOyjzWsTYMP9cTyTv" +
		"nvMRT1icaXpvPiInenXV$j5yaB#E2DVyJBUf1XBwn7RO9kLr9ifkDefp#jfbroZ6E#s66kK" +
		"SVBz5QFa$4XMFlI3WGPhb0qXwUhz2VDT3YdZXs3UIgisaNRwVMGSV3DEPnAbR4Vu3kWJq2z" +
		"4gUsD$CD1u5sVYBLMyR#jTDR63Ekl8#gmo8oVg15rB8Um8S8iXESHjQ#7y3QYuzywN1Z3CP" +
		"$u4kHVPrsdD4NQ3AAgkqklM#TsrBqVvRVXuXhel29HWmmph#Dimo9cd2v6tZjct7#MLPz37" +
		"mrQeUm6fQVHPjZWKiIFHtWlKQVQAFSbQ2xe2wIzZRngPhbE#KIreKSjoxnEFPQesYNnqjsH" +
		"8kXW4NHmaNLD7LNw7kYY0oA2AAiAobnefjSsWdlCU9qFKEOjCrvUzoRVFzgAixSLXlRW#nT" +
		"H4lmvTJh2zcPwKdUYj4egFbI5Nm5V0Uf#GrHn8QvVHkZ0WcE#Alk56MedcM5oach7KZFamu" +
		"l7c0p$gJtHZ7SQP8PPLo7#757TySW$1GcJ4UQ2u6Tfpo2ymbR$APH$6FpH7ogrL9Wg87wjK" +
		"qxzYr0MVOZrGOWn9YKDl33c9AzNCZz26vI#Cyz6kNIYZAh8tsYcfI3U$bSRlv4g$LGphFGY" +
		"uhr0a9Coc2WTFf$IGvLP07uJ4GvNrqedwICGVy#C#tN4lt1YpdmUxLgEiGZz9ULzPrwbVKX" +
		"R3Hu34K9FgMYp3$qwPQkPxzkBzenMl3TQzL9cEFbaD57sEK5T3tVcfsmXAjVEThr2XOTGvs" +
		"k4wsnvwz7EG9lXssdV0LTLApyrtugpONOvLdhM2kYvGt5vpdBLBbRb$oQgVZfHTXs4Ro14l" +
		"3ty9Bi$nkT$Y8uv5t8DmlYNFGh#UGRY$HIU1v0s1MbFevpo#TG7YMgjGOZwTU4ZgGyXR8Rm" +
		"RfJvJ9KPZNeRK0$oKbM$IhqEr##QSIqFrpDKkghJC1dfvq2N5vZNJO0blGbqnA3pMIW7cMa" +
		"SThiQyTLccRHCgxqD6w5zjhagSpZIBa0RCNSsX0$Kw56Qpi9rcFgpulqAV6MiqkikAx$sEZ" +
		"DCEjCCwrvjXfrMMsNIla9zu4$QQrvNFyCfesacofnXnjEljTAJqE#hl#aiowzmNgUXpwMrG" +
		"5depGTAK$qxhPMjpENGvQa8Sq3eVxv92BlQyg6VSgDLtD3$u#ZJ$qDR7i5rNuJ0dtOXRAjq" +
		"aOm#sN07P7OZEbRrYPFGXlOOEuxjPl7rrqOzZ3brzoFiHrIl1aAZp8DcVlkTg0TCIUyZxNF" +
		"5foTHGIgkTobPcv0s16MmtZckhYg3DL01VFIuYyphZEiLzlUGPc1U1PtUWd02z8a#x$SXhl" +
		"fycY5pCUfZ$Emy3DSxBBpfbJ6FmBVIVaEygYgFCIGD#4$2M54m1dMUnFNlLXqVP2RjL$NHb" +
		"ZfgVkYqryONlfxU3eJvBBqh23wP3jsbOpv9XrxJUu0U0q7lwU2VFX8q5WIzfAFlDO8V95#9" +
		"jct6DUQyoh1v#eUWSI3qYKOTaVyPqWtU64Urun27w7JCH#cONzCn1gMZpPK$HRWHX76d4TO" +
		"uoV23zAremp4Wp7cD7aNQD9J3cE$3UEe3pjheVpwiQ#eXxiFyKkyEXEXdLM1B7#R7yXXNKp" +
		"2crWCU7yRpUXYBVU1TvNo4roCFTHePSzHCf47VFlX18zYdmBZ6dEMx0VC4vX4VrehrcoEy6" +
		"UcmjGzZIuTAA8lnASMFDHnyoNSJKMEiApl0fwf2Rxv24FJIs5WRO$rP5UEG3sri31uTG5Mn" +
		"nlAfUTCtmDvlpBJ6c2TzdpZJgX#osLQDImnZe0$zruTrMtsqhH9qNWVzmZSFxUYDFecvrGU" +
		"zfxoETaBtjOiGmfToOUywi7rvOrx6dEg3BUeRPT0kFtpS3xn#Z9z#pAL#yFEZdNwqe$5K#5" +
		"bhnB7Mz5y6#JN3iNV6EiC7FVbFKNqD$TQFFk67BlozpRIK390X1$RrmrP#yApG4c4xCxyg$" +
		"DmFcsdm0J$iwhy4O#LPYX$cw0htMlByrwWGDlMhkQ4pndW$xEUVeEGrHdnoCNh#qGmxV6o6" +
		"nuysGmtpad#IIjCLV$X$3Tjwi09yLuFlDkk2FApDAw8lbCkoykbQPQDqfynKntKiYQZvgrQ" +
		"S5rbnqqwm#rtOBgYzKIxMQ0nxYrpu9KE$piLypp2Nvkv2kErmOGp7d0VVOZ$RiAA$vMK3$u" +
		"SHrCNSmU4ZUUXhcafheUPqJKDRrRp0DbXrEdSDuO7rXgRMqTH8yPYfyk3BsiLMMKB$Rd7Gk" +
		"jRG1nfFiM7l1fbh3vUk$Yr4r38VxVp8kgPRLFe0CpJsaYtVi$AR3BBLtMZ5DSUQENBvdOFt" +
		"5u3Z1ZEjeAALpnSvowTk2EVHyXypB5TaXZKwE$EJ1eHS3tHUjsfT4aRW#Wbb53Rj0pFCCzQ" +
		"hsAkmrythfWjjkgWJZh7LGmhRG2kjMXTd6NR039lPrkgQhNohPLQSNsQ6oJMSF9gyPiMfSG" +
		"Z$FvtNsc8hdcBijR1lI5OOKhgROT8Mgqnwp$1syV4AHr5udgRMAStgM6b9zQnuvm8htg6#3" +
		"UTM9vzcNpglcxyJBglQFJPC5LJxiMTgNZcqh5MEJaF#UFTy7jPUCprl9TgstQsUhQsQAc$i" +
		"0LE8sc6Tc8JvhntMEqbOWxOx2o7scpK#jEgqzeNpQTtP36jiij8QFs#6JHQROTFgPbZpU5k" +
		"zEymmHSs93FD2oZJLDjiudQhsdgq$CiDaDNThMBzgKynuinkjyin5B#smda#kPkDxDTA68G" +
		"rhq7ROeoM7sQqqWgoN5RQjLbfIFolUfBMpV5ErJa#UO#E1zLrEJUiwkMb8dVPMN9lbp4kvp" +
		"dcT#h0xrgPVk#SrrsnumdmEc9wmufs7ANvg3zDqcndMFCygawFkLTLym0pROKsTYlLPpQbM" +
		"cIIiyrAnVcoMOrutkr$LsME6QLZdvZngnazGzmJR$O1#$XgkUzbagJdqX56gp9zO5pwFwmK" +
		"AxyrMMKtvL#Uhh3IUwcnhFjQlVkpRQuqArqFwhmhR2o5riAOi1shobpCzoROt9#pXSWwQyO" +
		"paKDvUYQXDPSLJpOaPqqFohp33ykMijEJDuNnE4BOwpnSZPudYSwcLrbZjAPjzPuRDQwaoO" +
		"yomymYLtb#5KrM#RM$ODiKCCpkPOVvvs5zWJv7vk7dT8bs5wbvEvXeph8IrPDi2Crv1#KV#" +
		"ZTWZDi3rhJR#jweowbvBFlOgns4lKB5yQ1kTxMtxVdXQAWzFIycmuaapu7j34LvdNlkUiV9" +
		"gAJzFKklyfjZ3vw8F#4wnokHsCVPlIbV1UonEUVdOWn$NsBfEkZEyJ8jHu7ENTUsxhNXUBC" +
		"jvhTbyf4aLLVTBAotZH5kx7VS8mtatMuAwswrhtuxYopLHUxLgwjw6$sGLLh3Aq2jMFEqMA" +
		"#vNz#FyQkpmpxBojDCfvD0FwFlqlQAkg2DgYrhY155Jr13LHJLnlAWggeZAuZXnhD045qp$" +
		"IvR7xbBVgU$0UJjMMcy9x8B5$Q2X9ZynH7GMdKHRqKRaYDQYbMWfMeZcefbeAfg8ngAHE4a" +
		"q5DaYIpGG9uhwefvuLZmZiFCHmyHzubun2B71egFe80f4Uv4lseayaQlVeW#0l28fVuW#66" +
		"KcI5bOpOaFnGSo$huuLPmYpbCeXekRnBMYXunVBHwIOL$ZMbmbzeZVn6wnI$mgVX4xnSzYX" +
		"zWkjecjOelOB3Q9dyIFOgFO8DQBTMAj#46i4T#BrMALM2bMYELYcLWglXFVYYNY6x5O$2CE" +
		"YR$5N#AW#5Fy8Gw8$MAVs2j#5xF4J35RN2dwY3Ubv3V4wpXZZ1QlA7mNo$FNyhm0hLeghX5" +
		"NY29HA6uM$SMDuWRHJrmlhXEOdyKuCLPVgI#psMoGh9U4s7SEMtwhwpfcJXtQqSU3FWP1H$" +
		"euq8TYlfWdveev0lEE#49C4PCHVXBY3K$e#uFn3yHDEB#XlwQ$6bBgANb#IH#fhc#Kv#jqe" +
		"DMl1Tqj3jbAtoNFB#gOV$HdPVmF7VEHFagGBe8yRjAlrwyH#nnoxfJdtq6xzL#XWnNwDXqx" +
		"JXshH7qpQ9E#JlzUbbcjhqB#SgDjkDgehv7X1dMzNlz1V2acYa$rbU8zyQvuHumHRqiTZXR" +
		"JnGpnbPwhjzNNwjXzYxkTRHK37OWM1sDVKyYXBmZ6nkhluVoEZ8$HtzL7ozX1$QsmEhU3zk" +
		"Y$IKctYzi4$5pSAgz6YQV4IF6aU4AC48#BnyIZuX7niEWYJXPdolmpGASBh8S5zidY9T0Bu" +
		"ddnd7XHT9VvlK2NYvxYR7brgUWXBX7TPFmYesyWF4lq5fVPiA2Nw0$emntuRjFVbiZVr1U6" +
		"89yVZCrHuKpzP$rJtUPH#Zopvo4sLuMpWdcpLOZPGPyOfXURrlN##Wl1#7EEKZVeJyeMJPK" +
		"#$RcO93xJbmJ6CfaZnp8PKsDPY9n$hBZXxKW9yNMxpSj#1FHHOfb5e8NYV3r7RuFOg#92SO" +
		"4u5x5pH5UWkGVMcuD#Z1Rh8vNdT0ZZSRCyjmSLoDWy0Nk9UrIBBjSlqo$LBr5N5mTgwHSvk" +
		"UYdEQwa9#bdwcVef#bdoVZvAkTKUJv5xwAVh7T6h1Ee8qZYqe50Rw$duTnEptTmn8wABMAL" +
		"Y86u$1vJD3JnNqZtoLjXN8N9T1VIx7GBQ82YMq6tWUu5BOKwbYAy6$LCIgPDu6DIagGLYAz" +
		"0cLK8XuFMeSuwN0z7taw4Er5lFSBrAfodQ96DlaRU0jGTYFX0nFz2#1Uk$vQaqIo4iqXZC0" +
		"mpRklzYdo3thFHbYXeZ2HD$bUVHy3R94rHCeWf2gGn6eao9ccAaa5CKI2DqKEAxeoG7fIK1" +
		"D90N5rhaaOXFWfvesISgsjDqX2a3q7uCD8UHjup29z1#9Y3aa2QZ3$je2IG9kEFefv1Joag" +
		"KZIq57ed0detIdgo33If3FGuw5CRVQJe1KLJ53qB#X7#$IF24T3VDEXl6kAVAVe0QSPtwmp" +
		"QXVWkX1j0Jo2#KXAZ#P8uZKDeq7Z4noDlF6o2LGI8qGJ49o1j0gN0uJKGeqD8EuIokn7VZR" +
		"pf2B5k1p74EOq5VGLw3lGyfOAIQJB2joGbqvSeQtppworA1$b0QIel45hnBoGbWz91Fb2QI" +
		"Wk4LdmRvFq0lWQzYFYBmFOImfSGlepmPOIlWDVdeD4WuxsmxUZ77EtYkFuDzNv3kOretpye" +
		"#ofeAcWFqa5CCubUGzhhGKeY7NLt46T9o0VH6#3nFZ3D1F#Pk1w4#Cy8lv54z1r2apJwLXA" +
		"ZnQ25e1cWEPA87a3U$OY3MB8aZMQZdREHPePfPBoPFnVXnz3FOD1QN0#Jn44QhGQVrRZ#11" +
		"W$GPrx4Dw3S0tIlfV4QHd2PMR8CZ6mPIBC09K7LSHrHOJbG1L0AMXd2ih$RgC$e8C$eCDKv" +
		"5kaIKf3$bxWs0V##r3k9zHFHtewqlSZVJ$2Ww3be3#HRv86uegCU1BpePuFeHzr$IXx0Ea7" +
		"4Du1kXsq6VGBwCt$0q5vXhW=");

	private WorkingParseResult fWorking;

	// Collect the errors into a list of IParseErrors and let the custom error recovery mechanism handle it
	private class JSEvents extends Events
	{
		public void scannerError(Scanner.Exception e)
		{
		}

		public void syntaxError(Symbol token)
		{
			if (token != null && fWorking != null)
			{
				fWorking.addError(new ParseError(IJSConstants.CONTENT_TYPE_JS, token, IParseError.Severity.ERROR));
			}
		}

		public void unexpectedTokenRemoved(Symbol token)
		{
		}

		public void missingTokenInserted(Symbol token)
		{
		}

		public void missingTokensInserted(List<Symbol> tokens)
		{
			if (tokens != null && tokens.size() == 1 && tokens.get(0).getId() == Terminals.SEMICOLON)
			{
				// remove last error
				if (fWorking != null)
				{
					List<IParseError> errors = fWorking.getErrors();
					IParseError lastError = (errors.isEmpty()) ? null : errors.get(errors.size() - 1);

					if (lastError != null)
					{
						fWorking.removeError(lastError);
					}
				}
			}

			super.missingTokensInserted(tokens);
		}

		public void misspelledTokenReplaced(Symbol token)
		{
		}

		public void errorPhraseRemoved(Symbol error)
		{
		}
	}

	private final List<IRecoveryStrategy> recoveryStrategies;
	private JSFlexScanner fScanner;
	private IProblem.Severity fSemicolonSeverity = IProblem.Severity.WARNING;

    /**
     * attachPostDocumentationBlocks
     * 
     * @param root
     * @param source
     */
    private void attachPostDocumentationBlocks(JSParseRootNode root, String source)
    {
        // process each post-documentation block
        for (Symbol block : this.fScanner.getVSDocComments())
        {
            int index = block.getStart() - 1;

            while (index >= 0 && Character.isWhitespace(source.charAt(index)))
            {
                index--;
            }

            IParseNode node = root.getNodeAtOffset(index);

            if (node instanceof JSNode)
            {
                switch (node.getNodeType())
                {
                    case IJSNodeTypes.STATEMENTS:
                        IParseNode parent = node.getParent();

                        if (parent.getNodeType() == IJSNodeTypes.FUNCTION)
                        {
                            ((JSNode) parent).setPostDocumentation(block);
                        }
                        break;

                    default:
                        ((JSNode) node).setPostDocumentation(block);
                        break;
                }
            }
        }
    }

    /**
     * attachPreDocumentationBlocks
     * 
     * @param root
     * @param source
     */
    private void attachPreDocumentationBlocks(JSParseRootNode root, String source)
    {
        // process each pre-documentation block
        List<Symbol> sDocComments = fScanner.getSDocComments();
        for (Symbol comment : sDocComments)
        {
            int index = comment.getEnd() + 1;

            while (index < source.length() && Character.isWhitespace(source.charAt(index)))
            {
                index++;
            }

            IParseNode node = root.getNodeAtOffset(index);

            if (node instanceof JSNode)
            {
                if (node instanceof JSGroupNode && node.getFirstChild() instanceof JSFunctionNode)
                {
                    ((JSNode) node.getFirstChild()).setPreDocumentation(comment);
                }
                else if (node instanceof JSIdentifierNode && node.getParent() instanceof JSNameValuePairNode)
                {
                    // associate documentation with property's value
                    JSNameValuePairNode entry = (JSNameValuePairNode) node.getParent();
                    ((JSNode) entry.getValue()).setPreDocumentation(comment);
                }
                else
                {
                    IParseNode statement = ((JSNode) node).getContainingStatementNode();

                    if (statement instanceof JSAssignmentNode)
                    {
                        ((JSNode) statement.getLastChild()).setPreDocumentation(comment);
                    }
                    else
                    {
                        switch (node.getNodeType())
                        {
                            case IJSNodeTypes.VAR:
                                // associate documentation with first declared variable's value
                                JSVarNode varNode = (JSVarNode) node;
                                ((JSNode) varNode.getFirstChild().getLastChild()).setPreDocumentation(comment);
                                break;

                            default:
                                ((JSNode) node).setPreDocumentation(comment);
                                break;
                        }
                    }
                }
            }
        }
    }

	/**
	 * getNextSymbolIndex
	 * 
	 * @return
	 */
	protected Symbol getLastSymbol()
	{
		Symbol result = null;

		if (0 <= this.top && this.top < this._symbols.length)
		{
			result = this._symbols[this.top];
		}

		return result;
	}

    public synchronized ParseResult parse(IParseState parseState) throws java.lang.Exception
    {
        WorkingParseResult working = new WorkingParseResult();
        parse(parseState, working);
        return working.getImmutableResult();
    }


	/*
	 * (non-Javadoc)
	 * @see com.aptana.parsing.IParser#parse(com.aptana.parsing.IParseState)
	 */
	protected synchronized void parse(IParseState parseState, WorkingParseResult working) throws java.lang.Exception
	{
		fWorking = working;
		String severity = Platform.getPreferencesService().getString(JSCorePlugin.PLUGIN_ID, IPreferenceConstants.PREF_MISSING_SEMICOLON_SEVERITY, null, null);
		fSemicolonSeverity = IProblem.Severity.create(severity);

		// make sure we have some source
		String source = parseState.getSource();

		// create scanner and send source to it
		fScanner = new JSFlexScanner();
		fScanner.setSource(source);

		// determine if we need to collect and/or attach comments
		boolean attachComments = true;
		boolean collectComments = true;

		if (parseState instanceof JSParseState)
		{
			JSParseState jsParseState = (JSParseState) parseState;

			// NOTE: In order to attach comments, we have to collect them, hence the OR in collectComments
			attachComments = jsParseState.attachComments();
			collectComments = jsParseState.attachComments() || jsParseState.collectComments();
		}

		fScanner.setCollectComments(collectComments);

		try
		{
			JSParseRootNode result;
			try
			{
				// parse
				result = (JSParseRootNode) parse(fScanner);

				if (attachComments)
				{
					attachComments(source, result);
				}

				if (collectComments)
				{
					collectComments(result);
				}
			}
			finally
			{
				// clear scanner for garbage collection
				if (fScanner != null)
				{
					fScanner.yyclose();
					fScanner = null;
				}
			}

			// update node offsets
			int start = parseState.getStartingOffset();
			int length = source.length();

			// align root with zero-based offset
			result.setLocation(0, length - 1);

			if (start != 0)
			{
				// shift all offsets to the correct position
				ParseUtil.addOffset(result, start);
			}

			// store results in the parse state
			fWorking.setParseResult(result);
		}
		finally
		{
			fWorking = null;
		}
	}

	
    private void attachComments(String source, JSParseRootNode result)
    {
        // attach documentation
        attachPreDocumentationBlocks(result, source);
        attachPostDocumentationBlocks(result, source);
    }

    private void collectComments(JSParseRootNode result)
    {
        // create a list of all comments and attach to root node

        List<Symbol> sDocComments = fScanner.getSDocComments();
        List<Symbol> vsDocComments = fScanner.getVSDocComments();
        List<Symbol> singleLineComments = fScanner.getSingleLineComments();
        List<Symbol> multiLineComments = fScanner.getMultiLineComments();

        List<JSCommentNode> comments = new ArrayList<JSCommentNode>(sDocComments.size() + vsDocComments.size()
                + singleLineComments.size() + multiLineComments.size());

        for (Symbol symbol : sDocComments)
        {
            comments.add(new JSCommentNode(IJSNodeTypes.SDOC_COMMENT, symbol.getStart(), symbol.getEnd()));
        }

        for (Symbol symbol : vsDocComments)
        {
            comments.add(new JSCommentNode(IJSNodeTypes.VSDOC_COMMENT, symbol.getStart(), symbol.getEnd()));
        }

        for (Symbol symbol : singleLineComments)
        {
            comments.add(new JSCommentNode(IJSNodeTypes.SINGLE_LINE_COMMENT, symbol.getStart(), symbol.getEnd()));
        }

        for (Symbol symbol : multiLineComments)
        {
            comments.add(new JSCommentNode(IJSNodeTypes.MULTI_LINE_COMMENT, symbol.getStart(), symbol.getEnd()));
        }

        result.setCommentNodes(comments.toArray(new IParseNode[comments.size()]));
    }

	/*
	 * (non-Javadoc)
	 * @see beaver.Parser#recoverFromError(beaver.Symbol, beaver.Parser.TokenStream)
	 */
	@Override
	protected void recoverFromError(Symbol token, TokenStream in) throws IOException, Parser.Exception
	{
		boolean success = false;

		if (this.recoveryStrategies != null)
		{
			// NOTE: Consider building a Map<Object,List<IRecoveryStrategy>> which
			// would allow us to reduce the number of recovery strategies that will
			// be attempted based on the last symbol on the stack. We may need
			// catch-all cases: 1) try these before the mapped strategies, 2)
			// try the strategies, 3) try these after the mapped strategies
			for (IRecoveryStrategy strategy : this.recoveryStrategies)
			{
				if (strategy.recover(this, getLastSymbol(), token, in, report))
				{
					success = true;
					break;
				}
			}
		}

		if (success == false)
		{
			super.recoverFromError(token, in);
		}
	}

	public JSParser() {
		super(PARSING_TABLES);


		report = new JSEvents();

		// @formatter:off
		recoveryStrategies = new ArrayList<IRecoveryStrategy>(10);

		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.SEMICOLON, ";")
		{
			public boolean recover(IParser parser, Symbol lastToken, Symbol currentToken, TokenStream in, Events report)
					throws IOException
			{
				boolean recovered = super.recover(parser, lastToken, currentToken, in, report);
				if (recovered && fSemicolonSeverity != IProblem.Severity.IGNORE)
				{
					fWorking.addError(new ParseError(IJSConstants.CONTENT_TYPE_JS, lastToken, Messages.JSParser_MissingSemicolonMsg, fSemicolonSeverity));
				}
				return recovered;
			}
		});
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.RPAREN, ")", JSTokenType.SEMICOLON, ";"));
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.IDENTIFIER, "", JSTokenType.SEMICOLON, ";", JSTokenType.DOT, JSTokenType.NEW, JSTokenType.EQUAL));
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.IDENTIFIER, "", JSTokenType.DOT, JSTokenType.NEW, JSTokenType.EQUAL));
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.IDENTIFIER, "", JSTokenType.LPAREN));
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.IDENTIFIER, "", JSTokenType.COLON, ":", JSTokenType.DOT));
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.LCURLY, "{", JSTokenType.RCURLY, "}", JSTokenType.RPAREN));
		recoveryStrategies.add(new IRecoveryStrategy()
		{
			public boolean recover(IParser parser, Symbol lastToken, Symbol currentToken, TokenStream in, Parser.Events report) throws IOException
			{
				boolean result = false;

				if (top >= 2)
				{
					Symbol symbol1 = _symbols[top - 2];
					Symbol symbol2 = _symbols[top - 1];

					if (lastToken.getId() == JSTokenType.COMMA.getIndex() && symbol2.value instanceof List<?> && symbol1.getId() == JSTokenType.LPAREN.getIndex())
					{
						Symbol term = new Symbol(JSTokenType.IDENTIFIER.getIndex(), currentToken.getStart(), currentToken.getStart() - 1, "");
						Simulator sim = new Simulator();

						in.alloc(2);
						in.insert(term, currentToken);
						in.rewind();

						if (sim.parse(in))
						{
							result = true;

							in.rewind();

							report.missingTokenInserted(term);
						}
					}
				}

				return result;
			}
		});

		JSInsertionRecoveryStrategy completeProperty = new JSInsertionRecoveryStrategy(JSTokenType.IDENTIFIER, "");
		completeProperty.addCurrentTokenTypes(JSTokenType.RCURLY);
		recoveryStrategies.add(completeProperty);

		JSInsertionRecoveryStrategy completeProperty2 = new JSInsertionRecoveryStrategy(JSTokenType.COLON, ":", JSTokenType.IDENTIFIER, "");
		completeProperty2.addCurrentTokenTypes(JSTokenType.RCURLY);
		recoveryStrategies.add(completeProperty2);
		// @formatter:on
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 51: // CoverParenthesizedExpressionAndArrowParameterList = LPAREN Expression.e RPAREN
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			return new JSParametersNode(e);
			}
			case 52: // CoverParenthesizedExpressionAndArrowParameterList = LPAREN RPAREN
			{
					
			return new JSParametersNode();
			}
			case 53: // CoverParenthesizedExpressionAndArrowParameterList = LPAREN BindingRestElement.e RPAREN
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSRestElementNode e = (JSRestElementNode) _symbol_e.value;
					
			return new JSParametersNode(e);
			}
			case 54: // CoverParenthesizedExpressionAndArrowParameterList = LPAREN Expression.e COMMA BindingRestElement.r RPAREN
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol _symbol_r = _symbols[offset + 4];
					final JSRestElementNode r = (JSRestElementNode) _symbol_r.value;
					
			return new JSParametersNode(e, r);
			}
			case 59: // NullLiteral = NULL.n
			{
					final Symbol n = _symbols[offset + 1];
					
			return new JSNullNode(n);
			}
			case 60: // BooleanLiteral = TRUE.t
			{
					final Symbol t = _symbols[offset + 1];
					
			return new JSTrueNode(t);
			}
			case 61: // BooleanLiteral = FALSE.f
			{
					final Symbol f = _symbols[offset + 1];
					
			return new JSFalseNode(f);
			}
			case 62: // NumericLiteral = NUMBER.n
			{
					final Symbol n = _symbols[offset + 1];
					
			return new JSNumberNode(n);
			}
			case 63: // StringLiteral = STRING.s
			{
					final Symbol s = _symbols[offset + 1];
					
			return new JSStringNode(s);
			}
			case 64: // RegularExpressionLiteral = REGEX.r
			{
					final Symbol r = _symbols[offset + 1];
					
			return new JSRegexNode(r);
			}
			case 67: // ArrayLiteral = LBRACKET.l opt$Elision.e RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSElisionNode e = (JSElisionNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 3];
					
			if (e == null) {
				return new JSArrayNode(l, r);
			}
			return new JSArrayNode(l, r, e);
			}
			case 68: // ArrayLiteral = LBRACKET.l ElementList.e RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSElementsNode e = (JSElementsNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 3];
					
			return new JSArrayNode(l, r, e);
			}
			case 69: // ArrayLiteral = LBRACKET.l ElementList.e COMMA opt$Elision.n RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSElementsNode e = (JSElementsNode) _symbol_e.value;
					final Symbol _symbol_n = _symbols[offset + 4];
					final JSElisionNode n = (JSElisionNode) _symbol_n.value;
					final Symbol r = _symbols[offset + 5];
					
			if (n == null) {
				return new JSArrayNode(l, r, e);
			}
			e.addChild(n);
			return new JSArrayNode(l, r, e);
			}
			case 70: // ElementList = opt$Elision.n SingleExpression.e
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final JSElisionNode n = (JSElisionNode) _symbol_n.value;
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			if (n == null) {
				return new JSElementsNode(e);
			}
			return new JSElementsNode(n, e);
			}
			case 71: // ElementList = opt$Elision.n SpreadElement.e
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final JSElisionNode n = (JSElisionNode) _symbol_n.value;
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSSpreadElementNode e = (JSSpreadElementNode) _symbol_e.value;
					
			if (n == null) {
				return new JSElementsNode(e);
			}
			return new JSElementsNode(n, e);
			}
			case 72: // ElementList = ElementList.l COMMA opt$Elision.n SingleExpression.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSElementsNode l = (JSElementsNode) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 3];
					final JSElisionNode n = (JSElisionNode) _symbol_n.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final JSNode e = (JSNode) _symbol_e.value;
					
			if (n != null) {
				l.addChild(n);
			}
			l.addChild(e);

			return l;
			}
			case 73: // ElementList = ElementList.l COMMA opt$Elision.n SpreadElement.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSElementsNode l = (JSElementsNode) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 3];
					final JSElisionNode n = (JSElisionNode) _symbol_n.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final JSSpreadElementNode e = (JSSpreadElementNode) _symbol_e.value;
					
			if (n != null) {
				l.addChild(n);
			}
			l.addChild(e);

			return l;
			}
			case 74: // Elision = Elision.e COMMA
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSElisionNode e = (JSElisionNode) _symbol_e.value;
					
			e.addChild(new JSNullNode());

			return e;
			}
			case 75: // Elision = COMMA
			{
					
			return new JSElisionNode(new JSNullNode());
			}
			case 76: // SpreadElement = DOT_DOT_DOT.d SingleExpression.e
			{
					final Symbol d = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			return new JSSpreadElementNode(d, e);
			}
			case 77: // ObjectLiteral = LCURLY.l RCURLY.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol r = _symbols[offset + 2];
					
			return new JSObjectNode(l, r);
			}
			case 80: // ObjectLiteral = LCURLY.l PropertyDefinitionList.p opt$COMMA RCURLY.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_p = _symbols[offset + 2];
					final ArrayList _list_p = (ArrayList) _symbol_p.value;
					final JSNode[] p = _list_p == null ? new JSNode[0] : (JSNode[]) _list_p.toArray(new JSNode[_list_p.size()]);
					final Symbol r = _symbols[offset + 4];
					
			return new JSObjectNode(l, r, p);
			}
			case 81: // PropertyDefinitionList = PropertyDefinition
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 82: // PropertyDefinitionList = PropertyDefinitionList COMMA PropertyDefinition
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 84: // PropertyDefinition = PropertyName.n COLON.c SingleExpression.v
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final JSNode n = (JSNode) _symbol_n.value;
					final Symbol c = _symbols[offset + 2];
					final Symbol _symbol_v = _symbols[offset + 3];
					final JSNode v = (JSNode) _symbol_v.value;
					
			return new JSNameValuePairNode(n, c, v);
			}
			case 88: // LiteralPropertyName = IdentifierName.i
			{
					final Symbol i = _symbols[offset + 1];
					
			return new JSIdentifierNode(i);
			}
			case 91: // ComputedPropertyName = LBRACKET SingleExpression.e RBRACKET
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			return new JSComputedPropertyNameNode(e);
			}
			case 92: // Initializer = EQUAL.e SingleExpression.expr
			{
					final Symbol e = _symbols[offset + 1];
					final Symbol _symbol_expr = _symbols[offset + 2];
					final JSNode expr = (JSNode) _symbol_expr.value;
					
			return new JSInitializerNode(e, expr);
			}
			case 99: // Arguments = LPAREN RPAREN
			{
					
			return new JSArgumentsNode();
			}
			case 100: // Arguments = LPAREN ArgumentList.a RPAREN
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final ArrayList _list_a = (ArrayList) _symbol_a.value;
					final JSNode[] a = _list_a == null ? new JSNode[0] : (JSNode[]) _list_a.toArray(new JSNode[_list_a.size()]);
					
			return new JSArgumentsNode(a);
			}
			case 101: // ArgumentList = ArgumentListItem
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 102: // ArgumentList = ArgumentList COMMA ArgumentListItem
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 120: // Expression = Expression.l COMMA SingleExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSCommaNode(l, r);
			}
			case 122: // SingleExpression = SingleExpression.e PostUnaryOperator.o
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol o = _symbols[offset + 2];
					
			return new JSPostUnaryOperatorNode(o, e);
			}
			case 123: // SingleExpression = PreUnaryOperator.o SingleExpression.e
			{
					final Symbol o = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			return new JSPreUnaryOperatorNode(o, e);
			}
			case 124: // SingleExpression = SingleExpression.l BinaryArithmeticOperator.o SingleExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryArithmeticOperatorNode(l, o, r);
			}
			case 125: // SingleExpression = SingleExpression.l BinaryBooleanOperator.o SingleExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryBooleanOperatorNode(l, o, r);
			}
			case 126: // SingleExpression = SingleExpression.l QUESTION.q SingleExpression.t COLON.c SingleExpression.f
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol q = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final JSNode t = (JSNode) _symbol_t.value;
					final Symbol c = _symbols[offset + 4];
					final Symbol _symbol_f = _symbols[offset + 5];
					final JSNode f = (JSNode) _symbol_f.value;
					
			return new JSConditionalNode(l, q, t, c, f);
			}
			case 129: // SingleExpression = LeftHandSideExpression.l EQUAL.o SingleExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSAssignmentNode(l, o, r);
			}
			case 130: // SingleExpression = LeftHandSideExpression.l AssignmentOperator.o SingleExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSAssignmentNode(l, o, r);
			}
			case 132: // SingleExpression_NoLBF = SingleExpression_NoLBF.e PostUnaryOperator.o
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol o = _symbols[offset + 2];
					
			return new JSPostUnaryOperatorNode(o, e);
			}
			case 133: // SingleExpression_NoLBF = PreUnaryOperator.o SingleExpression.e
			{
					final Symbol o = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			return new JSPreUnaryOperatorNode(o, e);
			}
			case 134: // SingleExpression_NoLBF = SingleExpression_NoLBF.l BinaryArithmeticOperator.o SingleExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryArithmeticOperatorNode(l, o, r);
			}
			case 135: // SingleExpression_NoLBF = SingleExpression_NoLBF.l BinaryBooleanOperator.o SingleExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryBooleanOperatorNode(l, o, r);
			}
			case 136: // SingleExpression_NoLBF = SingleExpression_NoLBF.l QUESTION.q SingleExpression.t COLON.c SingleExpression.f
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol q = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final JSNode t = (JSNode) _symbol_t.value;
					final Symbol c = _symbols[offset + 4];
					final Symbol _symbol_f = _symbols[offset + 5];
					final JSNode f = (JSNode) _symbol_f.value;
					
			return new JSConditionalNode(l, q, t, c, f);
			}
			case 139: // SingleExpression_NoLBF = LeftHandSideExpression_NoLBF.l EQUAL.o SingleExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSAssignmentNode(l, o, r);
			}
			case 140: // SingleExpression_NoLBF = LeftHandSideExpression_NoLBF.l AssignmentOperator.o SingleExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSAssignmentNode(l, o, r);
			}
			case 144: // PrimaryExpression_NoLBF = THIS.t
			{
					final Symbol t = _symbols[offset + 1];
					
			return new JSThisNode(t);
			}
			case 145: // PrimaryExpression_NoLBF = Identifier.i
			{
					final Symbol i = _symbols[offset + 1];
					
			return new JSIdentifierNode(i);
			}
			case 155: // MemberExpression = MemberExpression.l LBRACKET.lb Expression.r RBRACKET.rb
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol lb = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					final Symbol rb = _symbols[offset + 4];
					
			return new JSGetElementNode(l, lb, r, rb);
			}
			case 156: // MemberExpression = MemberExpression.l DOT.o IdentifierName.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol r = _symbols[offset + 3];
					
			return new JSGetPropertyNode(l, o, new JSIdentifierNode(r));
			}
			case 160: // MemberExpression = NEW MemberExpression.e Arguments.r
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSArgumentsNode r = (JSArgumentsNode) _symbol_r.value;
					
			return new JSConstructNode(e, r);
			}
			case 162: // MemberExpression_NoLBF = MemberExpression_NoLBF.l LBRACKET.lb Expression.r RBRACKET.rb
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol lb = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					final Symbol rb = _symbols[offset + 4];
					
			return new JSGetElementNode(l, lb, r, rb);
			}
			case 163: // MemberExpression_NoLBF = MemberExpression_NoLBF.l DOT.o IdentifierName.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol r = _symbols[offset + 3];
					
			return new JSGetPropertyNode(l, o, new JSIdentifierNode(r));
			}
			case 167: // MemberExpression_NoLBF = NEW MemberExpression.e Arguments.r
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSArgumentsNode r = (JSArgumentsNode) _symbol_r.value;
					
			return new JSConstructNode(e, r);
			}
			case 171: // NewExpression = NEW NewExpression.e
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			return new JSConstructNode(e, new JSEmptyNode(e));
			}
			case 173: // NewExpression_NoLBF = NEW NewExpression.e
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			return new JSConstructNode(e, new JSEmptyNode(e));
			}
			case 174: // CallExpression = MemberExpression.l Arguments.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 2];
					final JSArgumentsNode r = (JSArgumentsNode) _symbol_r.value;
					
			return new JSInvokeNode(l, r);
			}
			case 175: // CallExpression = SUPER.s Arguments.r
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_r = _symbols[offset + 2];
					final JSArgumentsNode r = (JSArgumentsNode) _symbol_r.value;
					
			return new JSInvokeNode(new JSIdentifierNode(s), r);
			}
			case 176: // CallExpression = CallExpression.l Arguments.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 2];
					final JSArgumentsNode r = (JSArgumentsNode) _symbol_r.value;
					
			return new JSInvokeNode(l, r);
			}
			case 177: // CallExpression = CallExpression.l LBRACKET.lb Expression.r RBRACKET.rb
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol lb = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					final Symbol rb = _symbols[offset + 4];
					
			return new JSGetElementNode(l, lb, r, rb);
			}
			case 178: // CallExpression = CallExpression.l DOT.o IdentifierName.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol r = _symbols[offset + 3];
					
			return new JSGetPropertyNode(l, o, new JSIdentifierNode(r));
			}
			case 180: // CallExpression_NoLBF = MemberExpression_NoLBF.l Arguments.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 2];
					final JSArgumentsNode r = (JSArgumentsNode) _symbol_r.value;
					
			return new JSInvokeNode(l, r);
			}
			case 181: // CallExpression_NoLBF = SUPER.s Arguments.r
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_r = _symbols[offset + 2];
					final JSArgumentsNode r = (JSArgumentsNode) _symbol_r.value;
					
			return new JSInvokeNode(new JSIdentifierNode(s), r);
			}
			case 182: // CallExpression_NoLBF = CallExpression_NoLBF.l Arguments.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 2];
					final JSArgumentsNode r = (JSArgumentsNode) _symbol_r.value;
					
			return new JSInvokeNode(l, r);
			}
			case 183: // CallExpression_NoLBF = CallExpression_NoLBF.l LBRACKET.lb Expression.r RBRACKET.rb
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol lb = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					final Symbol rb = _symbols[offset + 4];
					
			return new JSGetElementNode(l, lb, r, rb);
			}
			case 184: // CallExpression_NoLBF = CallExpression_NoLBF.l DOT.o IdentifierName.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol r = _symbols[offset + 3];
					
			return new JSGetPropertyNode(l, o, new JSIdentifierNode(r));
			}
			case 235: // Statement = error
			{
					
			return new JSErrorNode();
			}
			case 250: // Statement_NoIf = error
			{
					
			return new JSErrorNode();
			}
			case 251: // EmptyStatement = SEMICOLON.s
			{
					final Symbol s = _symbols[offset + 1];
					
			JSNode node = new JSEmptyNode(s);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 264: // Block = LCURLY opt$StatementList.a RCURLY
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final ArrayList _list_a = (ArrayList) _symbol_a.value;
					final JSNode[] a = _list_a == null ? new JSNode[0] : (JSNode[]) _list_a.toArray(new JSNode[_list_a.size()]);
					
			if (a == null) {
				return new JSStatementsNode();
			}
			return new JSStatementsNode(a);
			}
			case 265: // StatementList = StatementList StatementListItem
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 266: // StatementList = StatementListItem
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 269: // LexicalDeclaration = LetOrConst.v BindingList.l SEMICOLON
			{
					final Symbol v = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final ArrayList _list_l = (ArrayList) _symbol_l.value;
					final JSNode[] l = _list_l == null ? new JSNode[0] : (JSNode[]) _list_l.toArray(new JSNode[_list_l.size()]);
					
			JSNode node = new JSVarNode(v, l);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 272: // BindingList = BindingList COMMA LexicalBinding
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 273: // BindingList = LexicalBinding
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 275: // VariableStatement = VAR.v VariableDeclarationList.l SEMICOLON
			{
					final Symbol v = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final ArrayList _list_l = (ArrayList) _symbol_l.value;
					final JSNode[] l = _list_l == null ? new JSNode[0] : (JSNode[]) _list_l.toArray(new JSNode[_list_l.size()]);
					
			JSNode node = new JSVarNode(v, l);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 276: // VariableDeclarationList = VariableDeclarationList COMMA VariableDeclaration
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 277: // VariableDeclarationList = VariableDeclaration
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 279: // VariableDeclaration = BindingPattern.p Initializer.i
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final JSNode p = (JSNode) _symbol_p.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final JSInitializerNode i = (JSInitializerNode) _symbol_i.value;
					
			return new JSDestructuringNode(p, i.getExpression());
			}
			case 282: // ObjectBindingPattern = LCURLY.l RCURLY.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol r = _symbols[offset + 2];
					
			return new JSObjectNode(l, r);
			}
			case 283: // ObjectBindingPattern = LCURLY.l BindingPropertyList.p RCURLY.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_p = _symbols[offset + 2];
					final ArrayList _list_p = (ArrayList) _symbol_p.value;
					final JSNode[] p = _list_p == null ? new JSNode[0] : (JSNode[]) _list_p.toArray(new JSNode[_list_p.size()]);
					final Symbol r = _symbols[offset + 3];
					
			return new JSObjectNode(l, r, p);
			}
			case 284: // ObjectBindingPattern = LCURLY.l BindingPropertyList.p COMMA RCURLY.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_p = _symbols[offset + 2];
					final ArrayList _list_p = (ArrayList) _symbol_p.value;
					final JSNode[] p = _list_p == null ? new JSNode[0] : (JSNode[]) _list_p.toArray(new JSNode[_list_p.size()]);
					final Symbol r = _symbols[offset + 4];
					
			return new JSObjectNode(l, r, p);
			}
			case 287: // ArrayBindingPattern = LBRACKET.l opt$Elision.e opt$BindingRestElement.n RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSElisionNode e = (JSElisionNode) _symbol_e.value;
					final Symbol _symbol_n = _symbols[offset + 3];
					final JSRestElementNode n = (JSRestElementNode) _symbol_n.value;
					final Symbol r = _symbols[offset + 4];
					
			if (e == null && n == null) {
				return new JSArrayNode(l, r);
			}
			JSElementsNode node;
			if (e != null) {
				node = new JSElementsNode(e);
				if (n != null) {
					node.addChild(n);
				}
			} else {
				node = new JSElementsNode(n);
			}
			return new JSArrayNode(l, r, node);
			}
			case 288: // ArrayBindingPattern = LBRACKET.l BindingElementList.n RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final JSElementsNode n = (JSElementsNode) _symbol_n.value;
					final Symbol r = _symbols[offset + 3];
					
			return new JSArrayNode(l, r, n);
			}
			case 289: // ArrayBindingPattern = LBRACKET.l BindingElementList.n COMMA opt$Elision.e opt$BindingRestElement.z RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final JSElementsNode n = (JSElementsNode) _symbol_n.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final JSElisionNode e = (JSElisionNode) _symbol_e.value;
					final Symbol _symbol_z = _symbols[offset + 5];
					final JSRestElementNode z = (JSRestElementNode) _symbol_z.value;
					final Symbol r = _symbols[offset + 6];
					
			if (e != null) {
				n.addChild(e);
			}
			// TODO Add null node to elision here?
			if (z != null) {
				n.addChild(z);
			}
			return new JSArrayNode(l, r, n);
			}
			case 290: // BindingPropertyList = BindingPropertyList COMMA BindingProperty
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 291: // BindingPropertyList = BindingProperty
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 292: // BindingElementList = BindingElementList.l COMMA opt$Elision.e BindingElement.elem
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSElementsNode l = (JSElementsNode) _symbol_l.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSElisionNode e = (JSElisionNode) _symbol_e.value;
					final Symbol _symbol_elem = _symbols[offset + 4];
					final JSNode elem = (JSNode) _symbol_elem.value;
					
			if (e != null) {
				l.addChild(e);
			}
			l.addChild(elem);
			return l;
			}
			case 293: // BindingElementList = opt$Elision.e BindingElement.elem
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSElisionNode e = (JSElisionNode) _symbol_e.value;
					final Symbol _symbol_elem = _symbols[offset + 2];
					final JSNode elem = (JSNode) _symbol_elem.value;
					
			if (e == null) {
				return new JSElementsNode(elem);
			}
			return new JSElementsNode(e, elem);
			}
			case 295: // BindingProperty = PropertyName.n COLON.c BindingElement.e
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final JSNode n = (JSNode) _symbol_n.value;
					final Symbol c = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					
			return new JSNameValuePairNode(n, c, e);
			}
			case 299: // BindingElement = BindingPattern.p opt$Initializer.i
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final JSNode p = (JSNode) _symbol_p.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final JSInitializerNode i = (JSInitializerNode) _symbol_i.value;
					
			if (i == null) {
				return new JSDestructuringNode(p);
			}
			return new JSDestructuringNode(p, i.getExpression());
			}
			case 300: // SingleNameBinding = Identifier.i opt$Initializer.z
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol _symbol_z = _symbols[offset + 2];
					final JSInitializerNode z = (JSInitializerNode) _symbol_z.value;
					
			if (z == null) {
				return new JSIdentifierNode(i);
			}
			return new JSDeclarationNode(new JSIdentifierNode(i), z.getEquals(), z.getExpression());
			}
			case 301: // BindingRestElement = DOT_DOT_DOT.d Identifier.i
			{
					final Symbol d = _symbols[offset + 1];
					final Symbol i = _symbols[offset + 2];
					
			return new JSRestElementNode(d, new JSIdentifierNode(i));
			}
			case 302: // ExpressionStatement = Expression_NoLBF.e SEMICOLON
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSNode e = (JSNode) _symbol_e.value;
					
			e.setSemicolonIncluded(true);
			return e;
			}
			case 303: // IfStatement = IF LPAREN.l Expression.e RPAREN.r Statement_NoIf.sn ELSE Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					final Symbol _symbol_sn = _symbols[offset + 5];
					final JSNode sn = (JSNode) _symbol_sn.value;
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSIfNode(l, e, r, sn, s);
			}
			case 304: // IfStatement = IF LPAREN.l Expression.e RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSIfNode(l, e, r, s, new JSEmptyNode(s));
			}
			case 305: // IfStatement_NoIf = IF LPAREN.l Expression.e RPAREN.r Statement_NoIf.sn ELSE Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					final Symbol _symbol_sn = _symbols[offset + 5];
					final JSNode sn = (JSNode) _symbol_sn.value;
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSIfNode(l, e, r, sn, s);
			}
			case 306: // IterationStatement = DO Statement.s WHILE LPAREN.l Expression.e RPAREN.r SEMICOLON.s1
			{
					final Symbol _symbol_s = _symbols[offset + 2];
					final JSNode s = (JSNode) _symbol_s.value;
					final Symbol l = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol s1 = _symbols[offset + 7];
					
 			JSNode node = new JSDoNode(s, l, e, r);
 			node.setSemicolonIncluded(true);
 			return node;
			}
			case 307: // IterationStatement = WHILE LPAREN.l Expression.e RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSWhileNode(l, e, r, s);
			}
			case 310: // IterationStatement = FOR LPAREN.l opt$Expression.e1 SEMICOLON.s1 opt$Expression.e2 SEMICOLON.s2 opt$Expression.e3 RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e1 = _symbols[offset + 3];
					final JSNode e1 = (JSNode) _symbol_e1.value;
					final Symbol s1 = _symbols[offset + 4];
					final Symbol _symbol_e2 = _symbols[offset + 5];
					final JSNode e2 = (JSNode) _symbol_e2.value;
					final Symbol s2 = _symbols[offset + 6];
					final Symbol _symbol_e3 = _symbols[offset + 7];
					final JSNode e3 = (JSNode) _symbol_e3.value;
					final Symbol r = _symbols[offset + 8];
					final Symbol _symbol_s = _symbols[offset + 9];
					final JSNode s = (JSNode) _symbol_s.value;
					
			JSNode expr1 = e1;
			if (expr1 == null) {
				expr1 = new JSEmptyNode(l);
			}
			JSNode expr2 = e2;
			if (expr2 == null) {
				expr2 = new JSEmptyNode(s1);
			}
			JSNode expr3 = e3;
			if (expr3 == null) {
				expr3 = new JSEmptyNode(s2);
			}
 			return new JSForNode(l, expr1, s1, expr2, s2, expr3, r, s);
			}
			case 311: // IterationStatement = FOR LPAREN.l VAR.v VariableDeclarationList.i SEMICOLON.s1 opt$Expression.e1 SEMICOLON.s2 opt$Expression.e2 RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayList _list_i = (ArrayList) _symbol_i.value;
					final JSNode[] i = _list_i == null ? new JSNode[0] : (JSNode[]) _list_i.toArray(new JSNode[_list_i.size()]);
					final Symbol s1 = _symbols[offset + 5];
					final Symbol _symbol_e1 = _symbols[offset + 6];
					final JSNode e1 = (JSNode) _symbol_e1.value;
					final Symbol s2 = _symbols[offset + 7];
					final Symbol _symbol_e2 = _symbols[offset + 8];
					final JSNode e2 = (JSNode) _symbol_e2.value;
					final Symbol r = _symbols[offset + 9];
					final Symbol _symbol_s = _symbols[offset + 10];
					final JSNode s = (JSNode) _symbol_s.value;
					
			JSNode expr1 = e1;
			if (expr1 == null) {
				expr1 = new JSEmptyNode(s1);
			}
			JSNode expr2 = e2;
			if (expr2 == null) {
				expr2 = new JSEmptyNode(s2);
			}
 			return new JSForNode(l, new JSVarNode(v, i), s1, expr1, s2, expr2, r, s);
			}
			case 312: // IterationStatement = FOR LPAREN.l LexicalDeclaration.decl opt$Expression.e1 SEMICOLON.s1 opt$Expression.e2 RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_decl = _symbols[offset + 3];
					final JSVarNode decl = (JSVarNode) _symbol_decl.value;
					final Symbol _symbol_e1 = _symbols[offset + 4];
					final JSNode e1 = (JSNode) _symbol_e1.value;
					final Symbol s1 = _symbols[offset + 5];
					final Symbol _symbol_e2 = _symbols[offset + 6];
					final JSNode e2 = (JSNode) _symbol_e2.value;
					final Symbol r = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
			JSNode expr1 = e1;
			if (expr1 == null) {
				expr1 = new JSEmptyNode(l);
			}
			JSNode expr2 = e2;
			if (expr2 == null) {
				expr2 = new JSEmptyNode(s1);
			}
			// FIXME Grab semicolon from decl to inject here?
 			return new JSForNode(l, decl, null, expr1, s1, expr2, r, s);
			}
			case 313: // IterationStatement = FOR LPAREN.l SingleExpression.i IN.in Expression.o RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol in = _symbols[offset + 4];
					final Symbol _symbol_o = _symbols[offset + 5];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForInNode(l, i, in, o, r, s);
			}
			case 314: // IterationStatement = FOR LPAREN.l VAR.v ForBinding.i IN.in Expression.o RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol in = _symbols[offset + 5];
					final Symbol _symbol_o = _symbols[offset + 6];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForInNode(l, new JSVarNode(v, i), in, o, r, s);
			}
			case 315: // IterationStatement = FOR LPAREN.l ForDeclaration.decl IN.in Expression.o RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_decl = _symbols[offset + 3];
					final JSNode decl = (JSNode) _symbol_decl.value;
					final Symbol in = _symbols[offset + 4];
					final Symbol _symbol_o = _symbols[offset + 5];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForInNode(l, decl, in, o, r, s);
			}
			case 316: // IterationStatement = FOR LPAREN.l SingleExpression.i OF.of SingleExpression.o RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol of = _symbols[offset + 4];
					final Symbol _symbol_o = _symbols[offset + 5];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForOfNode(l, i, of, o, r, s);
			}
			case 317: // IterationStatement = FOR LPAREN.l VAR.v ForBinding.i OF.of SingleExpression.o RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol of = _symbols[offset + 5];
					final Symbol _symbol_o = _symbols[offset + 6];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForOfNode(l, new JSVarNode(v, i), of, o, r, s);
			}
			case 318: // IterationStatement = FOR LPAREN.l ForDeclaration.decl OF.of SingleExpression.o RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_decl = _symbols[offset + 3];
					final JSNode decl = (JSNode) _symbol_decl.value;
					final Symbol of = _symbols[offset + 4];
					final Symbol _symbol_o = _symbols[offset + 5];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForOfNode(l, decl, of, o, r, s);
			}
			case 319: // IterationStatement_NoIf = DO Statement.s WHILE LPAREN.l Expression.e RPAREN.r SEMICOLON.s1
			{
					final Symbol _symbol_s = _symbols[offset + 2];
					final JSNode s = (JSNode) _symbol_s.value;
					final Symbol l = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol s1 = _symbols[offset + 7];
					
 			JSNode node = new JSDoNode(s, l, e, r);
 			node.setSemicolonIncluded(true);
 			return node;
			}
			case 320: // IterationStatement_NoIf = WHILE LPAREN.l Expression.e RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSWhileNode(l, e, r, s);
			}
			case 321: // IterationStatement_NoIf = FOR LPAREN.l opt$Expression.e1 SEMICOLON.s1 opt$Expression.e2 SEMICOLON.s2 opt$Expression.e3 RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e1 = _symbols[offset + 3];
					final JSNode e1 = (JSNode) _symbol_e1.value;
					final Symbol s1 = _symbols[offset + 4];
					final Symbol _symbol_e2 = _symbols[offset + 5];
					final JSNode e2 = (JSNode) _symbol_e2.value;
					final Symbol s2 = _symbols[offset + 6];
					final Symbol _symbol_e3 = _symbols[offset + 7];
					final JSNode e3 = (JSNode) _symbol_e3.value;
					final Symbol r = _symbols[offset + 8];
					final Symbol _symbol_s = _symbols[offset + 9];
					final JSNode s = (JSNode) _symbol_s.value;
					
			JSNode expr1 = e1;
			if (expr1 == null) {
				expr1 = new JSEmptyNode(l);
			}
			JSNode expr2 = e2;
			if (expr2 == null) {
				expr2 = new JSEmptyNode(s1);
			}
			JSNode expr3 = e3;
			if (expr3 == null) {
				expr3 = new JSEmptyNode(s2);
			}
 			return new JSForNode(l, expr1, s1, expr2, s2, expr3, r, s);
			}
			case 322: // IterationStatement_NoIf = FOR LPAREN.l VAR.v VariableDeclarationList.i SEMICOLON.s1 opt$Expression.e1 SEMICOLON.s2 opt$Expression.e2 RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayList _list_i = (ArrayList) _symbol_i.value;
					final JSNode[] i = _list_i == null ? new JSNode[0] : (JSNode[]) _list_i.toArray(new JSNode[_list_i.size()]);
					final Symbol s1 = _symbols[offset + 5];
					final Symbol _symbol_e1 = _symbols[offset + 6];
					final JSNode e1 = (JSNode) _symbol_e1.value;
					final Symbol s2 = _symbols[offset + 7];
					final Symbol _symbol_e2 = _symbols[offset + 8];
					final JSNode e2 = (JSNode) _symbol_e2.value;
					final Symbol r = _symbols[offset + 9];
					final Symbol _symbol_s = _symbols[offset + 10];
					final JSNode s = (JSNode) _symbol_s.value;
					
			JSNode expr1 = e1;
			if (expr1 == null) {
				expr1 = new JSEmptyNode(s1);
			}
			JSNode expr2 = e2;
			if (expr2 == null) {
				expr2 = new JSEmptyNode(s2);
			}
 			return new JSForNode(l, new JSVarNode(v, i), s1, expr1, s2, expr2, r, s);
			}
			case 323: // IterationStatement_NoIf = FOR LPAREN.l LexicalDeclaration.decl opt$Expression.e1 SEMICOLON.s1 opt$Expression.e2 RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_decl = _symbols[offset + 3];
					final JSVarNode decl = (JSVarNode) _symbol_decl.value;
					final Symbol _symbol_e1 = _symbols[offset + 4];
					final JSNode e1 = (JSNode) _symbol_e1.value;
					final Symbol s1 = _symbols[offset + 5];
					final Symbol _symbol_e2 = _symbols[offset + 6];
					final JSNode e2 = (JSNode) _symbol_e2.value;
					final Symbol r = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
			JSNode expr1 = e1;
			if (expr1 == null) {
				expr1 = new JSEmptyNode(l);
			}
			JSNode expr2 = e2;
			if (expr2 == null) {
				expr2 = new JSEmptyNode(s1);
			}
			// FIXME Grab semicolon from decl to inject here?
 			return new JSForNode(l, decl, null, expr1, s1, expr2, r, s);
			}
			case 324: // IterationStatement_NoIf = FOR LPAREN.l SingleExpression.i IN.in Expression.o RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol in = _symbols[offset + 4];
					final Symbol _symbol_o = _symbols[offset + 5];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForInNode(l, i, in, o, r, s);
			}
			case 325: // IterationStatement_NoIf = FOR LPAREN.l VAR.v ForBinding.i IN.in Expression.o RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol in = _symbols[offset + 5];
					final Symbol _symbol_o = _symbols[offset + 6];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForInNode(l, new JSVarNode(v, i), in, o, r, s);
			}
			case 326: // IterationStatement_NoIf = FOR LPAREN.l ForDeclaration.decl IN.in Expression.o RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_decl = _symbols[offset + 3];
					final JSNode decl = (JSNode) _symbol_decl.value;
					final Symbol in = _symbols[offset + 4];
					final Symbol _symbol_o = _symbols[offset + 5];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForInNode(l, decl, in, o, r, s);
			}
			case 327: // IterationStatement_NoIf = FOR LPAREN.l SingleExpression.i OF.of SingleExpression.o RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol of = _symbols[offset + 4];
					final Symbol _symbol_o = _symbols[offset + 5];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForOfNode(l, i, of, o, r, s);
			}
			case 328: // IterationStatement_NoIf = FOR LPAREN.l VAR.v ForBinding.i OF.of SingleExpression.o RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol of = _symbols[offset + 5];
					final Symbol _symbol_o = _symbols[offset + 6];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForOfNode(l, new JSVarNode(v, i), of, o, r, s);
			}
			case 329: // IterationStatement_NoIf = FOR LPAREN.l ForDeclaration.decl OF.of SingleExpression.o RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_decl = _symbols[offset + 3];
					final JSNode decl = (JSNode) _symbol_decl.value;
					final Symbol of = _symbols[offset + 4];
					final Symbol _symbol_o = _symbols[offset + 5];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForOfNode(l, decl, of, o, r, s);
			}
			case 330: // ForDeclaration = LetOrConst.v ForBinding.l
			{
					final Symbol v = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final JSNode l = (JSNode) _symbol_l.value;
					
			return new JSVarNode(v, l);
			}
			case 331: // ForBinding = Identifier.i
			{
					final Symbol i = _symbols[offset + 1];
					
			return new JSIdentifierNode(i);
			}
			case 333: // ContinueStatement = CONTINUE SEMICOLON
			{
					
			JSNode node = new JSContinueNode();
			node.setSemicolonIncluded(true);
			return node;
			}
			case 334: // ContinueStatement = CONTINUE Identifier.i SEMICOLON
			{
					final Symbol i = _symbols[offset + 2];
					
			JSNode node = new JSContinueNode(i);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 335: // BreakStatement = BREAK SEMICOLON
			{
					
			JSNode node = new JSBreakNode();
			node.setSemicolonIncluded(true);
			return node;
			}
			case 336: // BreakStatement = BREAK Identifier.i SEMICOLON
			{
					final Symbol i = _symbols[offset + 2];
					
			JSNode node = new JSBreakNode(i);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 337: // ReturnStatement = RETURN.r SEMICOLON
			{
					final Symbol r = _symbols[offset + 1];
					
			JSNode node = new JSReturnNode(new JSEmptyNode(r));
			node.setSemicolonIncluded(true);
			return node;
			}
			case 338: // ReturnStatement = RETURN Expression.e SEMICOLON
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			JSNode node = new JSReturnNode(e);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 339: // WithStatement = WITH LPAREN.l Expression.e RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSWithNode(l, e, r, s);
			}
			case 340: // WithStatement_NoIf = WITH LPAREN.l Expression.e RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSWithNode(l, e, r, s);
			}
			case 341: // SwitchStatement = SWITCH LPAREN.lp Expression.e RPAREN.rp CaseBlock.children
			{
					final Symbol lp = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol rp = _symbols[offset + 4];
					final Symbol _symbol_children = _symbols[offset + 5];
					final ArrayList children = (ArrayList) _symbol_children.value;
					
			final JSNode[] c1 = children == null ? new JSNode[0] : (JSNode[]) children.toArray(new JSNode[children.size()]);
			return new JSSwitchNode(lp, e, rp, null, null, c1);
			}
			case 345: // CaseBlock = LCURLY opt$CaseClauses.c1 DefaultClause.d opt$CaseClauses.c2 RCURLY
			{
					final Symbol _symbol_c1 = _symbols[offset + 2];
					final ArrayList _list_c1 = (ArrayList) _symbol_c1.value;
					final JSCaseNode[] c1 = _list_c1 == null ? new JSCaseNode[0] : (JSCaseNode[]) _list_c1.toArray(new JSCaseNode[_list_c1.size()]);
					final Symbol _symbol_d = _symbols[offset + 3];
					final JSDefaultNode d = (JSDefaultNode) _symbol_d.value;
					final Symbol _symbol_c2 = _symbols[offset + 4];
					final ArrayList _list_c2 = (ArrayList) _symbol_c2.value;
					final JSCaseNode[] c2 = _list_c2 == null ? new JSCaseNode[0] : (JSCaseNode[]) _list_c2.toArray(new JSCaseNode[_list_c2.size()]);
					
			List<JSNode> nodes = new ArrayList<JSNode>();
			if (c1 != null) {
				for (JSNode statement : c1)
				{
					nodes.add(statement);
				}
			}
			nodes.add(d);
			if (c2 != null) {
				for (JSNode statement : c2)
				{
					nodes.add(statement);
				}
			}
			return new Symbol(nodes);
			}
			case 346: // CaseClauses = CaseClause
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 347: // CaseClauses = CaseClauses CaseClause
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 348: // CaseClause = CASE Expression.e COLON.c opt$StatementList.s
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol c = _symbols[offset + 3];
					final Symbol _symbol_s = _symbols[offset + 4];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final JSNode[] s = _list_s == null ? new JSNode[0] : (JSNode[]) _list_s.toArray(new JSNode[_list_s.size()]);
					
			if (s == null) {
				return new JSCaseNode(e, c);
			}
			return new JSCaseNode(e, c, s);
			}
			case 349: // DefaultClause = DEFAULT COLON.c opt$StatementList.s
			{
					final Symbol c = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final JSNode[] s = _list_s == null ? new JSNode[0] : (JSNode[]) _list_s.toArray(new JSNode[_list_s.size()]);
					
			if (s == null) {
				return new JSDefaultNode(c);
			}
			return new JSDefaultNode(c, s);
			}
			case 350: // LabelledStatement = Identifier.i COLON.c LabelledItem.s
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol c = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final JSNode s = (JSNode) _symbol_s.value;
					
			JSNode id = new JSIdentifierNode(i);
			id.setLocation(i.getStart(), i.getEnd());

			return new JSLabelledNode(id, c, s);
			}
			case 351: // LabelledStatement_NoIf = Identifier.i COLON.c LabelledItem_NoIf.s
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol c = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final JSNode s = (JSNode) _symbol_s.value;
					
			JSNode id = new JSIdentifierNode(i);
			id.setLocation(i.getStart(), i.getEnd());

			return new JSLabelledNode(id, c, s);
			}
			case 356: // ThrowStatement = THROW Expression.e SEMICOLON
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			JSNode node = new JSThrowNode(e);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 357: // TryStatement = TRY Block.b Catch.c
			{
					final Symbol _symbol_b = _symbols[offset + 2];
					final JSStatementsNode b = (JSStatementsNode) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 3];
					final JSCatchNode c = (JSCatchNode) _symbol_c.value;
					
			return new JSTryNode(b, c, new JSEmptyNode(c));
			}
			case 358: // TryStatement = TRY Block.b Finally.f
			{
					final Symbol _symbol_b = _symbols[offset + 2];
					final JSStatementsNode b = (JSStatementsNode) _symbol_b.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final JSFinallyNode f = (JSFinallyNode) _symbol_f.value;
					
			return new JSTryNode(b, new JSEmptyNode(b), f);
			}
			case 359: // TryStatement = TRY Block.b Catch.c Finally.f
			{
					final Symbol _symbol_b = _symbols[offset + 2];
					final JSStatementsNode b = (JSStatementsNode) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 3];
					final JSCatchNode c = (JSCatchNode) _symbol_c.value;
					final Symbol _symbol_f = _symbols[offset + 4];
					final JSFinallyNode f = (JSFinallyNode) _symbol_f.value;
					
			return new JSTryNode(b, c, f);
			}
			case 360: // Catch = CATCH LPAREN CatchParameter.p RPAREN Block.b
			{
					final Symbol _symbol_p = _symbols[offset + 3];
					final JSNode p = (JSNode) _symbol_p.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final JSStatementsNode b = (JSStatementsNode) _symbol_b.value;
					
			return new JSCatchNode(p, b);
			}
			case 361: // Finally = FINALLY Block.b
			{
					final Symbol _symbol_b = _symbols[offset + 2];
					final JSStatementsNode b = (JSStatementsNode) _symbol_b.value;
					
			return new JSFinallyNode(b);
			}
			case 362: // CatchParameter = Identifier.i
			{
					final Symbol i = _symbols[offset + 1];
					
			return new JSIdentifierNode(i);
			}
			case 365: // FunctionDeclaration = FUNCTION Identifier.ident LPAREN FormalParameters.params RPAREN LCURLY FunctionBody.body RCURLY
			{
					final Symbol ident = _symbols[offset + 2];
					final Symbol _symbol_params = _symbols[offset + 4];
					final JSParametersNode params = (JSParametersNode) _symbol_params.value;
					final Symbol _symbol_body = _symbols[offset + 7];
					final JSStatementsNode body = (JSStatementsNode) _symbol_body.value;
					
			return new JSFunctionNode(
				new JSIdentifierNode(ident),
				params,
				body
			);
			}
			case 368: // FunctionExpression = FUNCTION.f opt$Identifier.ident LPAREN FormalParameters.params RPAREN LCURLY FunctionBody.body RCURLY
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol ident = _symbols[offset + 2];
					final Symbol _symbol_params = _symbols[offset + 4];
					final JSParametersNode params = (JSParametersNode) _symbol_params.value;
					final Symbol _symbol_body = _symbols[offset + 7];
					final JSStatementsNode body = (JSStatementsNode) _symbol_body.value;
					
			if (ident != null) {
				return new JSFunctionNode(
					new JSIdentifierNode(ident),
					params,
					body
				);
			}
			return new JSFunctionNode(
				new JSEmptyNode(f),
				params,
				body
			);
			}
			case 370: // FormalParameters = FormalParameterList.params
			{
					final Symbol _symbol_params = _symbols[offset + 1];
					final ArrayList params = (ArrayList) _symbol_params.value;
					
			final JSNode[] p = params == null ? new JSNode[0] : (JSNode[]) params.toArray(new JSNode[params.size()]);
			return new JSParametersNode(p);
			}
			case 371: // FormalParameters = 
			{
					
			return new JSParametersNode();
			}
			case 372: // FormalParameterList = FunctionRestParameter.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final JSRestElementNode p = (JSRestElementNode) _symbol_p.value;
					
			ArrayList lst = new ArrayList();
			lst.add(p);
			return new Symbol(lst);
			}
			case 374: // FormalParameterList = FormalsList.l COMMA FunctionRestParameter.p
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList _list_l = (ArrayList) _symbol_l.value;
					final JSNode[] l = _list_l == null ? new JSNode[0] : (JSNode[]) _list_l.toArray(new JSNode[_list_l.size()]);
					final Symbol _symbol_p = _symbols[offset + 3];
					final JSRestElementNode p = (JSRestElementNode) _symbol_p.value;
					
			_list_l.add(p);
			return _symbol_l;
			}
			case 375: // FormalsList = FormalsList COMMA FormalParameter
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 376: // FormalsList = FormalParameter
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 380: // FunctionStatementList = StatementList.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final JSNode[] s = _list_s == null ? new JSNode[0] : (JSNode[]) _list_s.toArray(new JSNode[_list_s.size()]);
					
			return new JSStatementsNode(s);
			}
			case 381: // FunctionStatementList = 
			{
					
			return new JSStatementsNode();
			}
			case 382: // ArrowFunction = ArrowParameters.p ARROW ConciseBody.body
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final JSParametersNode p = (JSParametersNode) _symbol_p.value;
					final Symbol _symbol_body = _symbols[offset + 3];
					final JSNode body = (JSNode) _symbol_body.value;
					
			return new JSArrowFunctionNode(p, body);
			}
			case 383: // ArrowParameters = Identifier.i
			{
					final Symbol i = _symbols[offset + 1];
					
			return new JSParametersNode(new JSIdentifierNode(i));
			}
			case 387: // MethodDefinition = Identifier.ident LPAREN StrictFormalParameters.params RPAREN LCURLY FunctionBody.body RCURLY
			{
					final Symbol ident = _symbols[offset + 1];
					final Symbol _symbol_params = _symbols[offset + 3];
					final JSParametersNode params = (JSParametersNode) _symbol_params.value;
					final Symbol _symbol_body = _symbols[offset + 6];
					final JSStatementsNode body = (JSStatementsNode) _symbol_body.value;
					
			// TODO Use JSNameValuePairNode to hold name with function as value?
			return new JSFunctionNode(
				new JSIdentifierNode(ident),
				params,
				body
			);
			}
			case 389: // MethodDefinition = GET PropertyName.n LPAREN RPAREN LCURLY FunctionBody.body RCURLY
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final JSNode n = (JSNode) _symbol_n.value;
					final Symbol _symbol_body = _symbols[offset + 6];
					final JSStatementsNode body = (JSStatementsNode) _symbol_body.value;
					
			return new JSNameValuePairNode(n, body);
			}
			case 390: // MethodDefinition = SET PropertyName.n LPAREN PropertySetParameterList.p RPAREN LCURLY FunctionBody.body RCURLY
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final JSNode n = (JSNode) _symbol_n.value;
					final Symbol _symbol_p = _symbols[offset + 4];
					final JSNode p = (JSNode) _symbol_p.value;
					final Symbol _symbol_body = _symbols[offset + 7];
					final JSStatementsNode body = (JSStatementsNode) _symbol_body.value;
					
			JSParametersNode params = new JSParametersNode(p);
			params.setLocation(p.getStartingOffset(), p.getEndingOffset());
			return new JSNameValuePairNode(n, params, body);
			}
			case 392: // GeneratorMethod = STAR PropertyName.n LPAREN StrictFormalParameters.params RPAREN LCURLY GeneratorBody.body RCURLY
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final JSNode n = (JSNode) _symbol_n.value;
					final Symbol _symbol_params = _symbols[offset + 4];
					final JSParametersNode params = (JSParametersNode) _symbol_params.value;
					final Symbol _symbol_body = _symbols[offset + 7];
					final JSStatementsNode body = (JSStatementsNode) _symbol_body.value;
					
			return new JSGeneratorFunctionNode(n, params, body);
			}
			case 393: // GeneratorDeclaration = FUNCTION STAR Identifier.i LPAREN FormalParameters.params RPAREN LCURLY GeneratorBody.body RCURLY
			{
					final Symbol i = _symbols[offset + 3];
					final Symbol _symbol_params = _symbols[offset + 5];
					final JSParametersNode params = (JSParametersNode) _symbol_params.value;
					final Symbol _symbol_body = _symbols[offset + 8];
					final JSStatementsNode body = (JSStatementsNode) _symbol_body.value;
					
			return new JSGeneratorFunctionNode(new JSIdentifierNode(i), params, body);
			}
			case 394: // GeneratorExpression = FUNCTION.f STAR opt$Identifier.i LPAREN FormalParameters.params RPAREN LCURLY GeneratorBody.body RCURLY
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol i = _symbols[offset + 3];
					final Symbol _symbol_params = _symbols[offset + 5];
					final JSParametersNode params = (JSParametersNode) _symbol_params.value;
					final Symbol _symbol_body = _symbols[offset + 8];
					final JSStatementsNode body = (JSStatementsNode) _symbol_body.value;
					
			JSNode name;
			if (i != null) {
				name = new JSIdentifierNode(i);
			} else {
				name = new JSEmptyNode(f);
			}
			return new JSGeneratorFunctionNode(name, params, body);
			}
			case 396: // YieldExpression = YIELD.y
			{
					final Symbol y = _symbols[offset + 1];
					
			return new JSYieldNode(y);
			}
			case 397: // YieldExpression = YIELD.y SingleExpression.e
			{
					final Symbol y = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			return new JSYieldNode(y, e);
			}
			case 398: // YieldExpression = YIELD.y STAR.s SingleExpression.e
			{
					final Symbol y = _symbols[offset + 1];
					final Symbol s = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					
			return new JSYieldNode(y, s, e);
			}
			case 401: // ClassDeclaration = CLASS Identifier.i LCURLY opt$ClassBody.b RCURLY
			{
					final Symbol i = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 4];
					final ArrayList _list_b = (ArrayList) _symbol_b.value;
					final JSNode[] b = _list_b == null ? new JSNode[0] : (JSNode[]) _list_b.toArray(new JSNode[_list_b.size()]);
					
			JSIdentifierNode name = new JSIdentifierNode(i);
			JSStatementsNode body;
			if (b != null) {
				body = new JSStatementsNode(b);
			} else {
				body = new JSStatementsNode();
			}
			
			return new JSClassNode(name, body);
			}
			case 402: // ClassDeclaration = CLASS Identifier.i EXTENDS SingleExpression.h LCURLY opt$ClassBody.b RCURLY
			{
					final Symbol i = _symbols[offset + 2];
					final Symbol _symbol_h = _symbols[offset + 4];
					final JSNode h = (JSNode) _symbol_h.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final ArrayList _list_b = (ArrayList) _symbol_b.value;
					final JSNode[] b = _list_b == null ? new JSNode[0] : (JSNode[]) _list_b.toArray(new JSNode[_list_b.size()]);
					
			JSIdentifierNode name = new JSIdentifierNode(i);
			JSStatementsNode body;
			if (b != null) {
				body = new JSStatementsNode(b);
			} else {
				body = new JSStatementsNode();
			}
			
			return new JSClassNode(name, h, body);
			}
			case 403: // ClassExpression = CLASS opt$Identifier.i LCURLY opt$ClassBody.b RCURLY
			{
					final Symbol i = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 4];
					final ArrayList _list_b = (ArrayList) _symbol_b.value;
					final JSNode[] b = _list_b == null ? new JSNode[0] : (JSNode[]) _list_b.toArray(new JSNode[_list_b.size()]);
					
			JSStatementsNode body;
			if (b != null) {
				body = new JSStatementsNode(b);
			} else {
				body = new JSStatementsNode();
			}
			if (i != null) {
				JSIdentifierNode name = new JSIdentifierNode(i);
				return new JSClassNode(name, body);
			}
			return new JSClassNode(body);
			}
			case 404: // ClassExpression = CLASS opt$Identifier.i EXTENDS SingleExpression.h LCURLY opt$ClassBody.b RCURLY
			{
					final Symbol i = _symbols[offset + 2];
					final Symbol _symbol_h = _symbols[offset + 4];
					final JSNode h = (JSNode) _symbol_h.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final ArrayList _list_b = (ArrayList) _symbol_b.value;
					final JSNode[] b = _list_b == null ? new JSNode[0] : (JSNode[]) _list_b.toArray(new JSNode[_list_b.size()]);
					
			JSStatementsNode body;
			if (b != null) {
				body = new JSStatementsNode(b);
			} else {
				body = new JSStatementsNode();
			}
			if (i != null) {
				JSIdentifierNode name = new JSIdentifierNode(i);
				return new JSClassNode(name, h, body);
			}
			return new JSClassNode(h, body);
			}
			case 406: // ClassElementList = ClassElement
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 407: // ClassElementList = ClassElementList ClassElement
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 409: // ClassElement = STATIC MethodDefinition.d
			{
					final Symbol _symbol_d = _symbols[offset + 2];
					final JSNode d = (JSNode) _symbol_d.value;
					
			if (d instanceof JSFunctionNode) {
				((JSFunctionNode)d).setStatic();
			} else if (d instanceof JSNameValuePairNode) {
				((JSNameValuePairNode)d).setStatic();
			}
			return d;
			}
			case 413: // Script = opt$ScriptBody.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final JSNode[] s = _list_s == null ? new JSNode[0] : (JSNode[]) _list_s.toArray(new JSNode[_list_s.size()]);
					
			return new JSParseRootNode(s);
			}
			case 417: // Module = opt$ModuleBody.m
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final ArrayList _list_m = (ArrayList) _symbol_m.value;
					final JSNode[] m = _list_m == null ? new JSNode[0] : (JSNode[]) _list_m.toArray(new JSNode[_list_m.size()]);
					
			return new JSParseRootNode(m);
			}
			case 419: // ModuleItemList = ModuleItemList ModuleItem
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 420: // ModuleItemList = ModuleItem
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 424: // ImportDeclaration = IMPORT ImportClause.c FromClause.f SEMICOLON
			{
					final Symbol _symbol_c = _symbols[offset + 2];
					final ArrayList c = (ArrayList) _symbol_c.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final String f = (String) _symbol_f.value;
					
			final JSNode[] clauses = c == null ? new JSNode[0] : (JSNode[]) c.toArray(new JSNode[c.size()]);
			return new JSImportNode(clauses, f);
			}
			case 425: // ImportDeclaration = IMPORT ModuleSpecifier.s SEMICOLON
			{
					final Symbol _symbol_s = _symbols[offset + 2];
					final String s = (String) _symbol_s.value;
					
			return new JSImportNode(s);
			}
			case 426: // ImportClause = ImportedDefaultBinding.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final JSImportSpecifierNode i = (JSImportSpecifierNode) _symbol_i.value;
					
			List<JSNode> nodes = new ArrayList<JSNode>();
			nodes.add(i);
			return new Symbol(nodes);
			}
			case 427: // ImportClause = NameSpaceImport.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final JSImportSpecifierNode i = (JSImportSpecifierNode) _symbol_i.value;
					
			List<JSNode> nodes = new ArrayList<JSNode>();
			nodes.add(i);
			return new Symbol(nodes);
			}
			case 428: // ImportClause = NamedImports.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNamedImportsNode l = (JSNamedImportsNode) _symbol_l.value;
					
			List<JSNode> nodes = new ArrayList<JSNode>();
			nodes.add(l);
			return new Symbol(nodes);
			}
			case 429: // ImportClause = ImportedDefaultBinding.i COMMA NameSpaceImport.n
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final JSImportSpecifierNode i = (JSImportSpecifierNode) _symbol_i.value;
					final Symbol _symbol_n = _symbols[offset + 3];
					final JSImportSpecifierNode n = (JSImportSpecifierNode) _symbol_n.value;
					
			List<JSNode> nodes = new ArrayList<JSNode>();
			nodes.add(i);
			nodes.add(n);
			return new Symbol(nodes);
			}
			case 430: // ImportClause = ImportedDefaultBinding.i COMMA NamedImports.l
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final JSImportSpecifierNode i = (JSImportSpecifierNode) _symbol_i.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final JSNamedImportsNode l = (JSNamedImportsNode) _symbol_l.value;
					
			List<JSNode> nodes = new ArrayList<JSNode>();
			nodes.add(i);
			nodes.add(l);
			return new Symbol(nodes);
			}
			case 431: // ImportedDefaultBinding = ImportedBinding.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final JSIdentifierNode i = (JSIdentifierNode) _symbol_i.value;
					
			return new JSImportSpecifierNode(i);
			}
			case 432: // NameSpaceImport = STAR.s AS ImportedBinding.i
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSIdentifierNode i = (JSIdentifierNode) _symbol_i.value;
					
			return new JSImportSpecifierNode(s, i);
			}
			case 433: // NamedImports = LCURLY RCURLY
			{
					
			return new JSNamedImportsNode();
			}
			case 434: // NamedImports = LCURLY ImportsList.l opt$COMMA RCURLY
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final ArrayList _list_l = (ArrayList) _symbol_l.value;
					final JSImportSpecifierNode[] l = _list_l == null ? new JSImportSpecifierNode[0] : (JSImportSpecifierNode[]) _list_l.toArray(new JSImportSpecifierNode[_list_l.size()]);
					
			return new JSNamedImportsNode(l);
			}
			case 436: // ImportsList = ImportsList COMMA ImportSpecifier
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 437: // ImportsList = ImportSpecifier
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 438: // ImportSpecifier = IdentifierName.i AS ImportedBinding.alias
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol _symbol_alias = _symbols[offset + 3];
					final JSIdentifierNode alias = (JSIdentifierNode) _symbol_alias.value;
					
			return new JSImportSpecifierNode(new JSIdentifierNode(i), alias);
			}
			case 439: // ImportSpecifier = ImportedBinding.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final JSIdentifierNode i = (JSIdentifierNode) _symbol_i.value;
					
			return new JSImportSpecifierNode(i);
			}
			case 441: // ImportedBinding = Identifier.i
			{
					final Symbol i = _symbols[offset + 1];
					
			return new JSIdentifierNode(i);
			}
			case 442: // ExportDeclaration = EXPORT STAR.s FromClause.f SEMICOLON
			{
					final Symbol s = _symbols[offset + 2];
					final Symbol _symbol_f = _symbols[offset + 3];
					final String f = (String) _symbol_f.value;
					
			return new JSExportNode(false, s, f);
			}
			case 443: // ExportDeclaration = EXPORT ExportClause.c FromClause.f SEMICOLON
			{
					final Symbol _symbol_c = _symbols[offset + 2];
					final ArrayList c = (ArrayList) _symbol_c.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final String f = (String) _symbol_f.value;
					
			final JSNode[] p = c == null ? new JSNode[0] : (JSNode[]) c.toArray(new JSNode[c.size()]);
			return new JSExportNode(false, p, f);
			}
			case 444: // ExportDeclaration = EXPORT ExportClause.d SEMICOLON
			{
					final Symbol _symbol_d = _symbols[offset + 2];
					final ArrayList d = (ArrayList) _symbol_d.value;
					
			final JSNode[] p = d == null ? new JSNode[0] : (JSNode[]) d.toArray(new JSNode[d.size()]);
			return new JSExportNode(false, p);
			}
			case 445: // ExportDeclaration = EXPORT VariableStatement.d
			{
					final Symbol _symbol_d = _symbols[offset + 2];
					final JSVarNode d = (JSVarNode) _symbol_d.value;
					
			return new JSExportNode(false, d);
			}
			case 446: // ExportDeclaration = EXPORT Declaration.d
			{
					final Symbol _symbol_d = _symbols[offset + 2];
					final JSNode d = (JSNode) _symbol_d.value;
					
			return new JSExportNode(false, d);
			}
			case 447: // ExportDeclaration = EXPORT DEFAULT HoistableDeclaration.d
			{
					final Symbol _symbol_d = _symbols[offset + 3];
					final JSFunctionNode d = (JSFunctionNode) _symbol_d.value;
					
			return new JSExportNode(true, d);
			}
			case 448: // ExportDeclaration = EXPORT DEFAULT SingleExpression.e SEMICOLON
			{
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					
			return new JSExportNode(true, e);
			}
			case 449: // ExportClause = LCURLY RCURLY
			{
					
			return new Symbol(new ArrayList());
			}
			case 451: // ExportsList = ExportsList COMMA ExportSpecifier
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 452: // ExportsList = ExportSpecifier
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 453: // ExportSpecifier = IdentifierName.i AS IdentifierName.alias
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol alias = _symbols[offset + 3];
					
			return new JSExportSpecifierNode(new JSIdentifierNode(i), new JSIdentifierNode(alias));
			}
			case 454: // ExportSpecifier = IdentifierName.i
			{
					final Symbol i = _symbols[offset + 1];
					
			return new JSExportSpecifierNode(new JSIdentifierNode(i));
			}
			case 65: // opt$Elision = 
			case 78: // opt$COMMA = 
			case 262: // opt$StatementList = 
			case 285: // opt$BindingRestElement = 
			case 297: // opt$Initializer = 
			case 308: // opt$Expression = 
			case 342: // opt$CaseClauses = 
			case 366: // opt$Identifier = 
			case 399: // opt$ClassBody = 
			case 411: // opt$ScriptBody = 
			case 415: // opt$ModuleBody = 
			{
				return new Symbol(null);
			}
			case 0: // $goal = Module
			case 2: // Identifier = IDENTIFIER
			case 3: // Identifier = GET
			case 4: // Identifier = IMPLEMENTS
			case 5: // Identifier = INTERFACE
			case 6: // Identifier = OF
			case 7: // Identifier = PACKAGE
			case 8: // Identifier = PRIVATE
			case 9: // Identifier = PROTECTED
			case 10: // Identifier = PUBLIC
			case 11: // Identifier = SET
			case 12: // Identifier = STATIC
			case 13: // Identifier = TARGET
			case 14: // IdentifierName = Identifier
			case 15: // IdentifierName = AWAIT
			case 16: // IdentifierName = BREAK
			case 17: // IdentifierName = CASE
			case 18: // IdentifierName = CATCH
			case 19: // IdentifierName = CLASS
			case 20: // IdentifierName = CONST
			case 21: // IdentifierName = CONTINUE
			case 22: // IdentifierName = DEBUGGER
			case 23: // IdentifierName = DEFAULT
			case 24: // IdentifierName = DELETE
			case 25: // IdentifierName = DO
			case 26: // IdentifierName = ELSE
			case 27: // IdentifierName = ENUM
			case 28: // IdentifierName = EXPORT
			case 29: // IdentifierName = EXTENDS
			case 30: // IdentifierName = FINALLY
			case 31: // IdentifierName = FOR
			case 32: // IdentifierName = FUNCTION
			case 33: // IdentifierName = IF
			case 34: // IdentifierName = IMPORT
			case 35: // IdentifierName = INSTANCEOF
			case 36: // IdentifierName = IN
			case 37: // IdentifierName = NEW
			case 38: // IdentifierName = RETURN
			case 39: // IdentifierName = SUPER
			case 40: // IdentifierName = SWITCH
			case 41: // IdentifierName = THIS
			case 42: // IdentifierName = THROW
			case 43: // IdentifierName = TRY
			case 44: // IdentifierName = TYPEOF
			case 45: // IdentifierName = VAR
			case 46: // IdentifierName = VOID
			case 47: // IdentifierName = WHILE
			case 48: // IdentifierName = WITH
			case 49: // IdentifierName = BooleanLiteral
			case 50: // IdentifierName = NullLiteral
			case 55: // Literal = NullLiteral
			case 56: // Literal = BooleanLiteral
			case 57: // Literal = NumericLiteral
			case 58: // Literal = StringLiteral
			case 66: // opt$Elision = Elision
			case 79: // opt$COMMA = COMMA
			case 83: // PropertyDefinition = SingleNameBinding
			case 85: // PropertyDefinition = MethodDefinition
			case 86: // PropertyName = LiteralPropertyName
			case 87: // PropertyName = ComputedPropertyName
			case 89: // LiteralPropertyName = StringLiteral
			case 90: // LiteralPropertyName = NumericLiteral
			case 93: // TemplateLiteral = NoSubstitutionTemplate
			case 95: // TemplateSpans = TemplateTail
			case 103: // ArgumentListItem = SingleExpression
			case 104: // ArgumentListItem = SpreadElement
			case 105: // MultiplicativeOperator = STAR
			case 106: // MultiplicativeOperator = FORWARD_SLASH
			case 107: // MultiplicativeOperator = PERCENT
			case 108: // AssignmentOperator = STAR_EQUAL
			case 109: // AssignmentOperator = FORWARD_SLASH_EQUAL
			case 110: // AssignmentOperator = PERCENT_EQUAL
			case 111: // AssignmentOperator = PLUS_EQUAL
			case 112: // AssignmentOperator = MINUS_EQUAL
			case 113: // AssignmentOperator = LESS_LESS_EQUAL
			case 114: // AssignmentOperator = GREATER_GREATER_EQUAL
			case 115: // AssignmentOperator = GREATER_GREATER_GREATER_EQUAL
			case 116: // AssignmentOperator = AMPERSAND_EQUAL
			case 117: // AssignmentOperator = CARET_EQUAL
			case 118: // AssignmentOperator = PIPE_EQUAL
			case 119: // Expression = SingleExpression
			case 121: // Expression_NoLBF = SingleExpression_NoLBF
			case 127: // SingleExpression = YieldExpression
			case 128: // SingleExpression = ArrowFunction
			case 131: // SingleExpression = LeftHandSideExpression
			case 137: // SingleExpression_NoLBF = YieldExpression
			case 138: // SingleExpression_NoLBF = ArrowFunction
			case 141: // SingleExpression_NoLBF = LeftHandSideExpression_NoLBF
			case 142: // PrimaryExpression = PrimaryExpression_NoLBF
			case 143: // PrimaryExpression = ObjectLiteral
			case 146: // PrimaryExpression_NoLBF = Literal
			case 147: // PrimaryExpression_NoLBF = ArrayLiteral
			case 148: // PrimaryExpression_NoLBF = FunctionExpression
			case 149: // PrimaryExpression_NoLBF = ClassExpression
			case 150: // PrimaryExpression_NoLBF = GeneratorExpression
			case 151: // PrimaryExpression_NoLBF = RegularExpressionLiteral
			case 152: // PrimaryExpression_NoLBF = TemplateLiteral
			case 153: // PrimaryExpression_NoLBF = CoverParenthesizedExpressionAndArrowParameterList
			case 154: // MemberExpression = PrimaryExpression
			case 157: // MemberExpression = MemberExpression.l TemplateLiteral
			case 158: // MemberExpression = SuperProperty
			case 161: // MemberExpression_NoLBF = PrimaryExpression_NoLBF
			case 164: // MemberExpression_NoLBF = MemberExpression_NoLBF.l TemplateLiteral
			case 165: // MemberExpression_NoLBF = SuperProperty
			case 170: // NewExpression = MemberExpression
			case 172: // NewExpression_NoLBF = MemberExpression_NoLBF
			case 186: // LeftHandSideExpression = NewExpression
			case 187: // LeftHandSideExpression = CallExpression
			case 188: // LeftHandSideExpression_NoLBF = NewExpression_NoLBF
			case 189: // LeftHandSideExpression_NoLBF = CallExpression_NoLBF
			case 190: // PostUnaryOperator = PLUS_PLUS
			case 191: // PostUnaryOperator = MINUS_MINUS
			case 192: // PreUnaryOperator = PostUnaryOperator
			case 193: // PreUnaryOperator = DELETE
			case 194: // PreUnaryOperator = VOID
			case 195: // PreUnaryOperator = TYPEOF
			case 196: // PreUnaryOperator = PLUS
			case 197: // PreUnaryOperator = MINUS
			case 198: // PreUnaryOperator = TILDE
			case 199: // PreUnaryOperator = EXCLAMATION
			case 200: // BinaryArithmeticOperator = MultiplicativeOperator
			case 201: // BinaryArithmeticOperator = PIPE
			case 202: // BinaryArithmeticOperator = CARET
			case 203: // BinaryArithmeticOperator = AMPERSAND
			case 204: // BinaryArithmeticOperator = PLUS
			case 205: // BinaryArithmeticOperator = MINUS
			case 206: // BinaryArithmeticOperator = LESS_LESS
			case 207: // BinaryArithmeticOperator = GREATER_GREATER
			case 208: // BinaryArithmeticOperator = GREATER_GREATER_GREATER
			case 209: // BinaryBooleanOperator = PIPE_PIPE
			case 210: // BinaryBooleanOperator = AMPERSAND_AMPERSAND
			case 211: // BinaryBooleanOperator = EXCLAMATION_EQUAL_EQUAL
			case 212: // BinaryBooleanOperator = EQUAL_EQUAL_EQUAL
			case 213: // BinaryBooleanOperator = EXCLAMATION_EQUAL
			case 214: // BinaryBooleanOperator = EQUAL_EQUAL
			case 215: // BinaryBooleanOperator = IN
			case 216: // BinaryBooleanOperator = INSTANCEOF
			case 217: // BinaryBooleanOperator = LESS
			case 218: // BinaryBooleanOperator = GREATER
			case 219: // BinaryBooleanOperator = LESS_EQUAL
			case 220: // BinaryBooleanOperator = GREATER_EQUAL
			case 221: // Statement = BlockStatement
			case 222: // Statement = VariableStatement
			case 223: // Statement = EmptyStatement
			case 224: // Statement = ExpressionStatement
			case 225: // Statement = IfStatement
			case 226: // Statement = BreakableStatement
			case 227: // Statement = ContinueStatement
			case 228: // Statement = BreakStatement
			case 229: // Statement = ReturnStatement
			case 230: // Statement = WithStatement
			case 231: // Statement = LabelledStatement
			case 232: // Statement = ThrowStatement
			case 233: // Statement = TryStatement
			case 234: // Statement = DebuggerStatement
			case 236: // Statement_NoIf = BlockStatement
			case 237: // Statement_NoIf = VariableStatement
			case 238: // Statement_NoIf = EmptyStatement
			case 239: // Statement_NoIf = ExpressionStatement
			case 240: // Statement_NoIf = IfStatement_NoIf
			case 241: // Statement_NoIf = BreakableStatement_NoIf
			case 242: // Statement_NoIf = ContinueStatement
			case 243: // Statement_NoIf = BreakStatement
			case 244: // Statement_NoIf = ReturnStatement
			case 245: // Statement_NoIf = WithStatement_NoIf
			case 246: // Statement_NoIf = LabelledStatement_NoIf
			case 247: // Statement_NoIf = ThrowStatement
			case 248: // Statement_NoIf = TryStatement
			case 249: // Statement_NoIf = DebuggerStatement
			case 252: // Declaration = HoistableDeclaration
			case 253: // Declaration = ClassDeclaration
			case 254: // Declaration = LexicalDeclaration
			case 255: // HoistableDeclaration = FunctionDeclaration
			case 256: // HoistableDeclaration = GeneratorDeclaration
			case 257: // BreakableStatement = IterationStatement
			case 258: // BreakableStatement = SwitchStatement
			case 259: // BreakableStatement_NoIf = IterationStatement_NoIf
			case 260: // BreakableStatement_NoIf = SwitchStatement
			case 261: // BlockStatement = Block
			case 263: // opt$StatementList = StatementList
			case 267: // StatementListItem = Statement
			case 268: // StatementListItem = Declaration
			case 270: // LetOrConst = LET
			case 271: // LetOrConst = CONST
			case 274: // LexicalBinding = VariableDeclaration
			case 278: // VariableDeclaration = SingleNameBinding
			case 280: // BindingPattern = ObjectBindingPattern
			case 281: // BindingPattern = ArrayBindingPattern
			case 286: // opt$BindingRestElement = BindingRestElement
			case 294: // BindingProperty = SingleNameBinding
			case 296: // BindingElement = SingleNameBinding
			case 298: // opt$Initializer = Initializer
			case 309: // opt$Expression = Expression
			case 332: // ForBinding = BindingPattern
			case 343: // opt$CaseClauses = CaseClauses
			case 352: // LabelledItem = Statement
			case 353: // LabelledItem = FunctionDeclaration
			case 354: // LabelledItem_NoIf = Statement_NoIf
			case 355: // LabelledItem_NoIf = FunctionDeclaration
			case 363: // CatchParameter = BindingPattern
			case 367: // opt$Identifier = Identifier
			case 369: // StrictFormalParameters = FormalParameters
			case 373: // FormalParameterList = FormalsList.l
			case 377: // FunctionRestParameter = BindingRestElement
			case 378: // FormalParameter = BindingElement
			case 379: // FunctionBody = FunctionStatementList
			case 384: // ArrowParameters = CoverParenthesizedExpressionAndArrowParameterList
			case 385: // ConciseBody = SingleExpression
			case 388: // MethodDefinition = GeneratorMethod
			case 391: // PropertySetParameterList = FormalParameter
			case 395: // GeneratorBody = FunctionBody
			case 400: // opt$ClassBody = ClassBody
			case 405: // ClassBody = ClassElementList
			case 408: // ClassElement = MethodDefinition
			case 410: // ClassElement = EmptyStatement
			case 412: // opt$ScriptBody = ScriptBody
			case 414: // ScriptBody = StatementList
			case 416: // opt$ModuleBody = ModuleBody
			case 418: // ModuleBody = ModuleItemList
			case 421: // ModuleItem = ImportDeclaration
			case 422: // ModuleItem = ExportDeclaration
			case 423: // ModuleItem = StatementListItem
			case 440: // ModuleSpecifier = STRING
			case 455: // NoSubstitutionTemplate = NO_SUB_TEMPLATE
			case 456: // TemplateHead = TEMPLATE_HEAD
			case 457: // TemplateMiddle = TEMPLATE_MIDDLE
			case 458: // TemplateTail = TEMPLATE_TAIL
			{
				return _symbols[offset + 1];
			}
			case 1: // $goal = $Script Script
			case 96: // TemplateSpans = TemplateMiddleList TemplateTail
			case 97: // TemplateMiddleList = TemplateMiddle Expression
			case 179: // CallExpression = CallExpression TemplateLiteral
			case 185: // CallExpression_NoLBF = CallExpression_NoLBF TemplateLiteral
			case 344: // CaseBlock = LCURLY opt$CaseClauses.c RCURLY
			case 364: // DebuggerStatement = DEBUGGER SEMICOLON
			case 386: // ConciseBody = LCURLY FunctionBody.body RCURLY
			case 435: // FromClause = FROM ModuleSpecifier.s
			case 450: // ExportClause = LCURLY ExportsList.l opt$COMMA RCURLY
			{
				return _symbols[offset + 2];
			}
			case 94: // TemplateLiteral = TemplateHead Expression TemplateSpans
			case 98: // TemplateMiddleList = TemplateMiddleList TemplateMiddle Expression
			case 159: // MemberExpression = NEW DOT TARGET
			case 166: // MemberExpression_NoLBF = NEW DOT TARGET
			case 169: // SuperProperty = SUPER DOT IdentifierName
			{
				return _symbols[offset + 3];
			}
			case 168: // SuperProperty = SUPER LBRACKET Expression RBRACKET
			{
				return _symbols[offset + 4];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
