package com.aptana.js.core.parsing;

import com.aptana.parsing.IRecoveryStrategy;
import com.aptana.parsing.ast.IParseNode;
import com.aptana.core.build.IProblem;
import com.aptana.js.core.JSCorePlugin;
import com.aptana.parsing.WorkingParseResult;
import com.aptana.js.core.preferences.IPreferenceConstants;
import java.io.IOException;
import com.aptana.parsing.ast.ParseError;
import java.util.ArrayList;
import java.util.List;
import com.aptana.parsing.IParser;
import com.aptana.parsing.ParseResult;
import org.eclipse.core.runtime.Platform;
import com.aptana.js.core.IJSConstants;
import com.aptana.parsing.IParseState;
import beaver.*;
import com.aptana.js.core.parsing.ast.*;
import com.aptana.parsing.util.ParseUtil;
import com.aptana.parsing.ast.IParseError;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "JS.grammar".
 */
public class JSParser extends Parser implements IParser{
	static public class AltGoals {
		static public final short Script = 102;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjNGUSKyNpdzdaxd9qf0XNSWS8wg48WWLHiI5MLF0KHB7hsHkAXIBstWK55Gy4wKfHEj9" +
		"Kb288IX6a5mK550NRs$ztz#qbxoMvN18J$x#VlxpxJ6RBxEntPsTdTnyn4XKEv6le9Ef9Kw" +
		"ajNyVNqXdq67r2Nz7NT1$TJmzGBtg2dgHdw5bwZWPIFbMXRAfCLQaQLQSQL9CEe5fKc#fGN" +
		"JgGwb5zUeU6yXdKM6PH2xw8wr0U7qOvN9TogHBjeXQYAHt4NUaSUfrUetD58Nr9MsYhyD16" +
		"xaBzQPjWQiBjUGbQ7yFjXL1S74mRQ2cVHmkJZnNwb$9HV3HF2SNABujgeYgm5jBhN9DVemO" +
		"sLde1MC#LxMaRtwOuq7vXe#MF5DTOFw65z4iPLbf1AvE2TJiVn3zGaPHkhA9#yliIfugQ$A" +
		"EsZDikFcc9op0prVNC72ZgqQb8EMJ4QN8zDQOlO8#hj4mTQaIdq6d0BKZmJZwItXMrHIq#t" +
		"1gU0jm7ACpMAZutR3wxqH$mFyofyZrhjMWBcMpsSGzgpEtXUshk6WLdameqFqskmppVdIga" +
		"yAQYi5M2UGRMqxc1NYNRg1tNvnpk1gGjC0g5j1kte1RKKE57UpMAGfrkpaEJZvHRQgHzwOK" +
		"8DZq2EDwWrHff4Lz4uunDYyfiofARSmctbyKgP$qAteGMmAQJKc1JqXxxC$uYsRGFdIagKr" +
		"OA#irMyOuUYH15#j7RrZx#augKXVYrCZlGgzeE$UruHn$eiWzv7#yZBsLIHWgYHmlwLQ44c" +
		"h2eJ3$JYrpDnWWylxDNTA1HX5X3pJ6BoVUeZbXplya$8#mGluekV3emDh9zNvpDnz7Bt8Q9" +
		"gt1nAh28I#tTYlg5OMdElVXqRcRcxWY#W6$acyI5N4IlmDDJWQKBDR5#v$FvXjH7U5Z$8T5" +
		"PveN57n#$8EfAeYBhDnwj8tpov$yLVXiUC428iFKoIpGMJUWWxBROTLFGysSuKxo5CKyDwt" +
		"aDZnTde6OyUdup1JtNmQuuN9pETSDwtYBEmQvOH2FGytHh1QsY2OW7LzFvT07Df8$eJhfBH" +
		"zMtg3SzH7CuWpCvYyRJKpIDfjCCcaMpQG2tez7KN9m2FNxkmu$mlVGcxUPdQHYDfB4ik1PN" +
		"4WTfJzVwQNseVdg#VFqyYCwYCQ8zlyl3#K0#LUy8BVWDKKdu#HH#dpyLpKGRSOJ84UToZYY" +
		"s5egBU3Tv#Ff4na8zr0v1atb1#MEXAVGfBUA3QN5Y8nBdssEXPTnP58aYVRfA36rpZNOpRu" +
		"g2zblw9X6Kz1vl4uUALlIzGRk3TjAFegj2QorFs5Fsq9zaSUKeU1F0AeyaoJMOkHfNvPbEJ" +
		"q5fTJw0QyDJJWRUUl2K8f5ZVPCWVgKvb$EvIVdu#H0#b9jQAnFhGHo7NT2sT$aMEWIdYQRO" +
		"mvNcY#XYhRaLdqHDnB6YDKv6weJMGZI0fivybZmTA5I$7N2RwSuNKXkKwXv4hcY4M7CO7Kb" +
		"jnM5yh6XEpUXAkflkeKvq8HLJP#f2NUbIkeowqULq1LrDrz2rT1qTGzTJ2Tr0Dz9DT3FTGh" +
		"VIRNGxtK6Nq5LqEBMae#W4wiWNK#l4R42RvPNoAxcSEqUnyXry5z$FtHESntlabHLPsTh93" +
		"t1lVZ317Xwjk0T#d9$av$Zf17juAOOUzl2Bx4U4IAo70HNte7oHN#N#Jb$K9rvu80$0RQ4X" +
		"#EjSoaEaXz$XOP9rlnCiITsjF#6B7vWUb4zt4XShFVmX7y#Ja#2BHJo7fr4plY91Fso2yS$" +
		"ZB$chA1PUWLNMIdeJjF0lCStX7zQ6XEUmHcnpQEtclqBda2tHKLQMbRYXy2AUP0aVFZiWxX" +
		"JnbzPNlCZwcheBFxKHUIQU578xaI#E5mMy1xtz2in$VmuLjZdM35UiSyHtqL0SOdrcpLSd0" +
		"TllH3lh4tuFVjVT#XZ#DOusyKXh7ht4e$WolfH7M7D5IseX$uHVh4u2jWNMvqviE9Dyort5" +
		"2U94SPB0ZcFUCfr76#bFSG5kr2ruFPV2RfTG6zJQpoRrvWPyeKAeIv9YDwt9EQU4#nxfct7" +
		"NODgyMo8W9FuE2BiZtSO6XlsQgBaK#5n2InKwf9E4pTeOWitUhyz5Ig5J9pkawJk5Zjypbk" +
		"gE#Mp38r6$YqSfV3o2d4#IiF6TRcpQ5lR9qppQtymZpjBujDs0ZtWaxFQNmeVqY6HZ2vjJs" +
		"svbC#l0XRfmkmrssatFR0gnEUscPvCYu7FPZIV#itQBD9ykkuq5jZ4uPwi7d$OAJVqwnHem" +
		"wnIvndeDt6xMQTdZMAUs5iocqf9SkpMBDATbirdkuyGMwKcXlrNufB6biSMFBR4JfBbT0K7" +
		"KqrVCemxShfoZDkUx$xKPIMFxzs6Bzztd$Wh$xK4zzeX$Iyg8WoiwEIDshsYYVGb6ck1JVg" +
		"GfUnBkeSARP2Bl6UrddirC3$7wGMc5VX2lnY59rxWtsHhvlgHhV3Zf6fz9kiQFawxnywHhN" +
		"9nqZIkJhd5jqZLkIBh6hKdN#7s56ik9Zb5ZM6pnzz#a#VV$GinfpMdDQSt$eEPuJu8Yus#S" +
		"84FEvjn0d$ktKV2cutf4PZ3DFxdhpBdVTJRdF2xGTT$opVgjM2pd$aH6ytSi4FrvE49PZty" +
		"Q8tUcfsFUim$LJIOb#9s0X50crkxVt5kwJRfDkeshpUV$mTZ#jzkuzXPULVxUmZD2P2#FiW" +
		"#LxLtBU4SSkzV9$5X2OrXjUhieyZRE9Oxqnl$esKYt#UVQXBxNT$lfUL7yj7i5vyROJhinh" +
		"ulGbHTTLbI9IxFzdCrFXBGwE4ghf#BfWMUdQgI1DJqtZXZJdfV7FjFyTHoQ7un3Tb0Sikz7" +
		"TZ8y7UBGCZ54zhCeicx9DJ5BHkl$fpXcrXEoqznIyKvZdhKLh4oY#N7Ww1c7R5$ZYxV6qUR" +
		"vE6G7nY4RpnY$YKDsS#ooeaQ8RDEOlQXLp997nonvRCoInyKiUNpCaYV6B7blp9AFnYpvUC" +
		"oIiS$Ht9WbFuvPSddCakjYbOnwHdLBBenPClRUjySikJzMIN5cbFLvITaRFVrzk#3RFSTxF" +
		"cwWmzIsG3oC95McvIVN6xrWElZVB7JblUej7vy8Qgk$RnT1of5oVniWMjzNHYXpZuzSc8XR" +
		"Lz1thCYSrkfgedfmV54mkr9H##0MV8AnGSBuk5ruhVh#iJXQ1BwbgR6tT7vlC$14wYDIBV5" +
		"L4RxxUNRWUxI7ypdYI76aNHQGEAUyxLSS9OxI4cU6rt6dybgvD1mZMbGi5P0#FE8tITGtMh" +
		"hhCteFn5nx9VN4MkfDVN2EwuixmyFqY8wnZ#lrfKwyzcfydbx0MMem2VBGPEf7$UarUfq6q" +
		"41wWzv4cHVdjLBAeo7q3XLGPNgNXjC86acZw0iQGsF9JuN4mAGaoxWVgtiQejgC563rq5iu" +
		"RRwD6qyeri$eAjn5IYbNOrq2j3RMyS3Q4NSNXLLnndtAHZjNSuLrVagmgbjO2Qb$DGZ5clo" +
		"##c1ajcL2#o94LqQCLMDTJT$G0gJSClcO$mB8pDGoEu5kBNsBaZoSSkTZ$dFfLzf7Y#Yt5E" +
		"2sCHDc9XItxKrgJjLy4ks6J6Mg0jyRZBen6cj9s6o#Zz7uSITE5TBni4ieKdkUFu6VAQHZO" +
		"U6bz2KGZGGY6wazbeyq$WBzELj$bgGGQITW3RTfAN3aOiNRwtaoqhPD2nmsdKdpaClLkSwe" +
		"AKonJRtuYsHJHbHw4KYJtsyp7U#kYHX5yZ3cxp5gEugKsM6ajiCO4#$oT5a1NOc$dsal$PA" +
		"II5UiKNQE49NpK7E5mLX8rm9ZLP32M0ACgTaXFWUUy1sY61xrFZ2M#Vu5y9Kyu1X96$KEaN" +
		"migynkbHyXgkRfQ5LWl5lzJQGzmE85ybHWATLhenF#KX$XYp6wLUWjFFxa8S8hcwiw5U6Jt" +
		"tS#T0wchlWCxJiN9$SLiBfjy#Jtd0UT0jgxHHZrUBsxZazHp$qmuXBTNwIUrOXppSx4sX#z" +
		"b46Pb4K#ogPAEggM$psp7BGjqN$AMnjGGsf41r5ZQa87qo5qA1NXxdeOJgq5MdCY#lr0cKl" +
		"xwJpzFjYEinwzMY#aeJICZi2SNWRzb#kzAX#b1JIEhajmB1tr3b52bqGPYughMsWJ91CTaJ" +
		"sMOXtbIW8xH2AMLsW7mmRbexLFYebeluGcuKyOj7bedm#hszy$IHIlm5yU$BPyl8bfzcfqL" +
		"o2sDt1vYXTzvQDUUOe7$Ly6kZnX$4gpwaT4zGubaMWFan27RVpHBUI5d5FpO7XJeOvWZ5xL" +
		"tnha2tH4zvWJcXz$dNIftSCFz6CWrkJhlsRmfERK0ZVMbjGAzyoZwHWwbbhJSTI6ZiUjyqJ" +
		"SSq#Ya#aKEfLEetPqEhMdC#XCEelEfdFeNEg0KyvBz3AzGg#Yb#84RJ0OI8hrwYZV1igB6k" +
		"hJSY8zgB5MP6KroxcWn7eGCVIGg#No4lRuM7hOhYD4OZrqZQ47fNa3v9oQLOHG7jWLjPU2p" +
		"zAZjDT5dkvNvLLSBmJPFR2scAt7coHVLFjQCVGa6lyADTx1I4LRxOMGI7GEO$53svSIdSDO" +
		"l8JD$8JEOM#qLkMNwfskHDyLgkhuCHZnBG$ansvRI7DC3vNrAS2FoACifZ3$$JbalGfpNTY" +
		"SyJsNkW23VHAm$QuRSgE1sSOs3fWc8FK1VQZFKrEGxWAfBad2flfsOhiGksOfB9AhoMFUt9" +
		"JWLY7mETRSUFpelv0yKZyedqhJm6SeXBeaATYq9WSsv1YaVAZKaTO8aHu5obFlbi0Bov1fT" +
		"7duLE#MbFtoaeNDxSd8s$FP4Ic5JisdIjls6stm#36VXJG1ASodnZP5EfwaOTlingPrQto1" +
		"de0laCvL#6oxqJXyJW0kZG$fASd65ZQdjjtAPjE12oKLs4tDR2gnEUscPjDjDnlV$w$T8ir" +
		"dkDtKEZ2hGQ$GrAzJ$NPBhzF06Z3hD83HkKvjhzKHFBbsesQHvhHiDijxdDWYrgVGtofwqj" +
		"ZIs19S2$6Vlipj2WYYdhvY7NNmTkKSjNqU#b#SaJIsVncsfB$xrBZitR5VCaOSND596h5hH" +
		"KFZTub56WV2SYDDG2BX7cAwISQfEMXfHm$9VmUUrfZMcDQOrbYnnfJ5txJcjEQqvhJcjERo" +
		"JeA9$JjA08txR3vAwneRlEb8r#DyWqMpG#hiTvBks$OoMcwteqxwhLWiv$v4xFitB13zKQZ" +
		"3oZh#qnZrTnvYthF$1iRSVz87$zMzfTkaswJRfDlyDxI9vpuOisnWxrBVdeodX$SI6iD4qz" +
		"laSlRnUOxq#l$esKYt#KVRQ8yeQnExd$ehFZV6SDfDoSg3xC9upuj0knKhB$PMySZsYbCwR" +
		"kn0dpeyASEUo3Z3$2okcOv3DXMIAR9EY4K#Zhuo8R4ZjRD47$$$s#I$JZOjcPPCIoPRClXT" +
		"6iTxFlMjLNoE3SJ32581BRETR$GS$wL2C5Lgl#MZeO5ltKMI2gRSRnoZzRquGfbhV5g34z#" +
		"s2lgE4PdBMgK6QN1yKJ2xKj7xAA75HdF2#A0ZhDPy$xZ4jUEvlhSPA8tGHwHQf6U6wh2$#s" +
		"c#Hxk8HiCBIYD$7pJ2$Zk99cd#QOIw26KHf5RIobZaZFGk8j7jGVqB2jxvfFuF69Hv0X7N0" +
		"zq8UW3vMrLzAWZF8D3T9Zt4y4E2zNMd45Ng3xuC6QJh$e3y5aVxdk4w3ymYgjmIl05uN$0s" +
		"6CD0y6AYd67Wjn7LEGByITH$OTeCmLZhEFGsDUKpK5vAL2KVzjblwlmshtExpQlSb2hx98C" +
		"mXXN0E2MydDTXxhkZVW$IiysOdaBPoNRQbq5Khp9HrIntEz75dLU$HUnXwAWFVXIe7#oz6$" +
		"nwkzup2eHyrMBJFjFctXxGtnZvLuWEECikEw1724PZQ#z8qtQFoVzkyuo9fhnAi4rj#8WOP" +
		"iOp1p8ve9DYirNrxS3v472rXM#yWtRA1btikgfBa6zcS5L1#bIJlYlOFgCfvEyYgkOFrvrn" +
		"5UXAErtjPflNUnRfgS2Rxx3lzl2s3F$FM0gQ1bfEb0NVpfZkqBqVkjv5swsmuJj6pqz8BtN" +
		"h4V3bZD#8iYU3hySyDOIkZk2L3HxrM#ExohTFPYFKAxjyPlB67baF8tsWASi9QGEV4DUQzC" +
		"MGLVxHDbZlkpUOfZvcl5z3HltVBh5#Cyy3bQ3THF3pJVrZy2aJD$Wfe$icm$k4z6zynzFIO" +
		"DqTKe$nYwQE$1E6ls3uI$Wu0$noXymLe756xpscJFsYo3dWrplabhZxyhphpjVx1dWskCio" +
		"7WMUjz4MyIuJlb5d3ThrCFgmLkjas#dgPZoCc9sLXpcT2Uu18LRvMe4Ncl4U2J#mq1QKrG5" +
		"z$W9zTo9zjAa$dwX#TPHj8AfbubxMpP2l17ujOcvjyEl04JEpheTCPoC3LlyEjCDwonfeok" +
		"x6simtOzs8$7nJ$ghDwmz6$MV0RkRC2onYB#f$HbmV2huQXBmF$MQjSTibIzdgM#Z5diLOP" +
		"raRJVbcXymVMBVFW6CT#7mW#5hM7aVzMlGzpKxxQg9lsCPx6CPsDl9rmJ5Etz4OuwC67x3K" +
		"dmuENwmrtem1lkcRY$owe5w1sEThRgVh8dxuMeF37tod8nvLiSkpqLzzn44lVBbsQxii1pR" +
		"ElXpvwypStuEoWo03MzH#sSYS29anoCyoVNrekD9$AkXCqCWW5j#Ne6k2#PpEQF#7gOClYr" +
		"dWYCc#iQRiGz0asFL1av$iq8MuuvjkqbyxvyEX7xxacs5a49zyc2FVUenbRRWiOL$sFGSo#" +
		"wuFy#53FFBz3enPnkROhp87e0pnreUOv$iSTGU3hxJhCqSWZJMHWNtU1v$DL6FPPlHjWknn" +
		"3lnRZEshWQgRiaL8OwwpEvd#5Y9T78vLM8unmgSgdMbqtOgwildgXZnyFXjxMVRzyAyTfho" +
		"gpRDs1dLaOw$BxXN19gVPdByAARy$ahsJGNW#2wRjFHQ7mISSu$qKTks2MFEAdS$3cglgSx" +
		"Jf7Quptukz3F4f7skXzaVWpN1K6WuE7$MF1OSV#YU0tm9kpXlriEwfsA7Nd0ro6zlS$mcmj" +
		"7VtatkygLkGAliaWp1En07$$iXrZFYKsz4Xsp#OzalaHnCLUAFfntnjjULzVODjHStmlZnX" +
		"vrFqNMBpwaCDN#okztO8oVSAQHzX$dDB7UF1ESAx9LIcF88yOcf1DlWEy6f6toIR5zJ2M5y" +
		"pEEuBjidES#lmAzbwuRePwpLteT7LpiZMGVeis6v1K2v3XBVDlicT5rT76FS6crVV5oohLk" +
		"gMOHCFigS4oyG8XuvzJldmFZBwG1vnDkCAa$$0vfuHKTeWTZ87yxKV2S7Kq87bRPjN#i7ct" +
		"fwEkbt1T44lH$kxR4vbvoMlMxz$k3iVQMuoNWocQPtfxtN5CUU8gmM3mjjadkVE2vm52ygr" +
		"Wv5PvyxxYz36TOz1Vpz2zur1cNeh7Usnh#IPEImmz#LAkssUVODZ3AuzagX6OJ2TroOSLzu" +
		"5HkvCHxzpR9vZpi8vvknKuqv7kxApxkS6#rnrzhFBU6jGBgkLaUzhSu#96NmrqilCE3A2yX" +
		"mu1qSYo9P6gNF6yGV3wxsDojB0QyvkEQCDNsl6ED0nnlwcR9xD$RYJ5G1tZH#2CXwS4xBCE" +
		"JndhyrpAzcyPbsR5#2ybJV6bBKrkYv4EVRicYME$kOQcHUDp0sGUHNvgNQURZFZg8K#vuIF" +
		"pnzoT$NtHli13fkOix2lerlE4tQkWinjmRGtBDOQlAiSycs2QSzHuR8PwXpdME##6f5rUku" +
		"CQPSJJ1UCSjSLZ0wHpOsaCrXFpwXpfmF3cCXoNdymxNyP$RnZock0BhRJsMNnj8RDHSYzoj" +
		"Cu15jhTrvqev17TfENogxoFdclx27laNVBxl8kUQUyGzukRvEtoblapV8cUOCiaTVBgxJy1" +
		"Q3pPR7i8E5BSgdHye4SAt4#bU$AF#LVSXXIxu26c5hSVkGWq5joYSv$8HVZ4#THkK3Y52vn" +
		"qfMu7SbFvIVoDTbVFYUVbS$8f#LJyadvX7nSFYOVbO$8X#L3igzyKFQHlMKlsLC#8E#Ni#K" +
		"i#P6SAMV8wNAQd2gdoCboaZNQ6YNdoRbo3dH#B2VA2NAy72VDxypBCVfpb1o9pw6oLBujtv" +
		"Hlo85oW7mzn3OP#lCAUIC#ZmcKubulZvRNIAn9UH2e4QWXg06e45IW8Yhu7qP#l#mdNvMlo" +
		"9VbI$95#O9ytjfXVKzaVQTghVqMxe9oWvR43KAkaT$ez6gvJ$ugVv5x9UwPSeVSBhU1usuf" +
		"rqhSVEMNSgLSOVtin6lz92yBeFJBD$1PMzQI1uICogS$QygVvKzoZzmjT#by3OcxWgoYqxY" +
		"PoMnvdRnMQzrkj6#rDkDpdGMKLiZlq5jxTBjBG1V3Dpg1TvJdIDmk9KuR4ZSrUOOyHUhV19" +
		"R7opQGEGxKMeqD9UtaYPeV2phDb9qgJv8xvMQvIRQ5vDVoAxbSbo#J9ykBmD#0PNxHjlbUV" +
		"tudjyej8QXsXOoyLI3Laa8UsJoGofTv#CpHwVeoL#h$axgyKjODRMFzABl8pewy1Vh3#iib" +
		"yuEifrlNaI6$wYkF2AGEC$nGUPvi8XlBSnrIpTGAqQd33IyAr3Kr$13GmQgbxd6DjLxpBTO" +
		"cNLiz85$Ly4pKxfM$wpHkeNAq72xdMoCijI8MolS2s9TPIwqbrXScjpXGlYZ43jDTEVr$Th" +
		"C#icPQqwrPElsfgPccFwTQKwp95cxUreVM1xfaeiITrjhcq87xaZKUDCvwty9wjSPQxrcut" +
		"$F5z1inIEXVUYq5zI0FI82ye4ow7sLEkXDqbw5RGBU2xW5DH3SJmHz0UvioQ1xqsEJLD1df" +
		"oP3v6BmdIFdN5kHxecu6#0oqcme#rV1t3Grtq0ZKJKDRzHkLDo9$8$9hmTSY$wqc3xseVzV" +
		"KGrjHlXLy8VX2bBqANaQln46zD7deDl1myeA4uHv3ma6UaBIY34Vxih9mtJSPkhq2UYa6UZ" +
		"bEUl1lq4EWDnpqkg573VK5OJy3CVN6s8V0DaEGVjDGVvIz1gve4TABmDLkypwftr0MclgWV" +
		"AuczGl5GjDRI2iQXFGWr0t2dAYryYdAr6$kgLzeV1i#lGry6yhMWQy3$mBoYy4N8pyCV1Zo" +
		"Gq6ZGG#37g4iK0Oz3$uyk5hHwZkKprCsg1B8P#hAU32z7ktdGrRHOqW$XZuU1tyS$0dm9y2" +
		"VXCuNGDYpGKpRKROTUVNhk4iWCmlODw3iAP3wBx4LFOtqCm7oqaR8VmxPxr6dw5ca#m43LZ" +
		"s8gJlIcy4$qAJ#5OmDUUX3JKmJGED8$Qwo#grYfljGVWUueXsQFFg$Nnc5SOs2lar8ZmKV0" +
		"3lS3PgE$BsQ1CX30q7xGKk1RwdcYWHz2Le6kUMQ1Cq6dsquTcyGqy#WlQ1zoEy3$mdqAsWd" +
		"v7Q2V#MWrQH#UTj3Fo0T98#c7v7#6dm5sgtGt4jpaDw5z2xKhGHV2Ru6D0dq3Ufjye248O#" +
		"X3DgD$6waTqDc3$WUj5a5lWhyPj0Df7uBd6a1wBd$0x1#kC8=");

	private WorkingParseResult fWorking;

	// Collect the errors into a list of IParseErrors and let the custom error recovery mechanism handle it
	private class JSEvents extends Events
	{
		public void scannerError(Scanner.Exception e)
		{
		}

		public void syntaxError(Symbol token)
		{
			if (token != null && fWorking != null)
			{
				fWorking.addError(new ParseError(IJSConstants.CONTENT_TYPE_JS, token, IParseError.Severity.ERROR));
			}
		}

		public void unexpectedTokenRemoved(Symbol token)
		{
		}

		public void missingTokenInserted(Symbol token)
		{
		}

		public void missingTokensInserted(List<Symbol> tokens)
		{
			if (tokens != null && tokens.size() == 1 && tokens.get(0).getId() == Terminals.SEMICOLON)
			{
				// remove last error
				if (fWorking != null)
				{
					List<IParseError> errors = fWorking.getErrors();
					IParseError lastError = (errors.isEmpty()) ? null : errors.get(errors.size() - 1);

					if (lastError != null)
					{
						fWorking.removeError(lastError);
					}
				}
			}

			super.missingTokensInserted(tokens);
		}

		public void misspelledTokenReplaced(Symbol token)
		{
		}

		public void errorPhraseRemoved(Symbol error)
		{
		}
	}

	private final List<IRecoveryStrategy> recoveryStrategies;
	private JSFlexScanner fScanner;
	private IProblem.Severity fSemicolonSeverity = IProblem.Severity.WARNING;

    /**
     * attachPostDocumentationBlocks
     * 
     * @param root
     * @param source
     */
    private void attachPostDocumentationBlocks(JSParseRootNode root, String source)
    {
        // process each post-documentation block
        for (Symbol block : this.fScanner.getVSDocComments())
        {
            int index = block.getStart() - 1;

            while (index >= 0 && Character.isWhitespace(source.charAt(index)))
            {
                index--;
            }

            IParseNode node = root.getNodeAtOffset(index);

            if (node instanceof JSNode)
            {
                switch (node.getNodeType())
                {
                    case IJSNodeTypes.STATEMENTS:
                        IParseNode parent = node.getParent();

                        if (parent.getNodeType() == IJSNodeTypes.FUNCTION)
                        {
                            ((JSNode) parent).setPostDocumentation(block);
                        }
                        break;

                    default:
                        ((JSNode) node).setPostDocumentation(block);
                        break;
                }
            }
        }
    }

    /**
     * attachPreDocumentationBlocks
     * 
     * @param root
     * @param source
     */
    private void attachPreDocumentationBlocks(JSParseRootNode root, String source)
    {
        // process each pre-documentation block
        List<Symbol> sDocComments = fScanner.getSDocComments();
        for (Symbol comment : sDocComments)
        {
            int index = comment.getEnd() + 1;

            while (index < source.length() && Character.isWhitespace(source.charAt(index)))
            {
                index++;
            }

            IParseNode node = root.getNodeAtOffset(index);

            if (node instanceof JSNode)
            {
                if (node instanceof JSGroupNode && node.getFirstChild() instanceof JSFunctionNode)
                {
                    ((JSNode) node.getFirstChild()).setPreDocumentation(comment);
                }
                else if (node instanceof JSIdentifierNode && node.getParent() instanceof JSNameValuePairNode)
                {
                    // associate documentation with property's value
                    JSNameValuePairNode entry = (JSNameValuePairNode) node.getParent();
                    ((JSNode) entry.getValue()).setPreDocumentation(comment);
                }
                else
                {
                    IParseNode statement = ((JSNode) node).getContainingStatementNode();

                    if (statement instanceof JSAssignmentNode)
                    {
                        ((JSNode) statement.getLastChild()).setPreDocumentation(comment);
                    }
                    else
                    {
                        switch (node.getNodeType())
                        {
                            case IJSNodeTypes.VAR:
                                // associate documentation with first declared variable's value
                                JSVarNode varNode = (JSVarNode) node;
                                ((JSNode) varNode.getFirstChild().getLastChild()).setPreDocumentation(comment);
                                break;

                            default:
                                ((JSNode) node).setPreDocumentation(comment);
                                break;
                        }
                    }
                }
            }
        }
    }

	/**
	 * getNextSymbolIndex
	 * 
	 * @return
	 */
	protected Symbol getLastSymbol()
	{
		Symbol result = null;

		if (0 <= this.top && this.top < this._symbols.length)
		{
			result = this._symbols[this.top];
		}

		return result;
	}

    public synchronized ParseResult parse(IParseState parseState) throws java.lang.Exception
    {
        WorkingParseResult working = new WorkingParseResult();
        parse(parseState, working);
        return working.getImmutableResult();
    }


	/*
	 * (non-Javadoc)
	 * @see com.aptana.parsing.IParser#parse(com.aptana.parsing.IParseState)
	 */
	protected synchronized void parse(IParseState parseState, WorkingParseResult working) throws java.lang.Exception
	{
		fWorking = working;
		String severity = Platform.getPreferencesService().getString(JSCorePlugin.PLUGIN_ID, IPreferenceConstants.PREF_MISSING_SEMICOLON_SEVERITY, null, null);
		fSemicolonSeverity = IProblem.Severity.create(severity);

		// make sure we have some source
		String source = parseState.getSource();

		// create scanner and send source to it
		fScanner = new JSFlexScanner();
		fScanner.setSource(source);

		// determine if we need to collect and/or attach comments
		boolean attachComments = true;
		boolean collectComments = true;

		if (parseState instanceof JSParseState)
		{
			JSParseState jsParseState = (JSParseState) parseState;

			// NOTE: In order to attach comments, we have to collect them, hence the OR in collectComments
			attachComments = jsParseState.attachComments();
			collectComments = jsParseState.attachComments() || jsParseState.collectComments();
		}

		fScanner.setCollectComments(collectComments);

		try
		{
			JSParseRootNode result;
			try
			{
				// parse
				result = (JSParseRootNode) parse(fScanner);

				if (attachComments)
				{
					attachComments(source, result);
				}

				if (collectComments)
				{
					collectComments(result);
				}
			}
			finally
			{
				// clear scanner for garbage collection
				if (fScanner != null)
				{
					fScanner.yyclose();
					fScanner = null;
				}
			}

			// update node offsets
			int start = parseState.getStartingOffset();
			int length = source.length();

			// align root with zero-based offset
			result.setLocation(0, length - 1);

			if (start != 0)
			{
				// shift all offsets to the correct position
				ParseUtil.addOffset(result, start);
			}

			// store results in the parse state
			fWorking.setParseResult(result);
		}
		finally
		{
			fWorking = null;
		}
	}

	
    private void attachComments(String source, JSParseRootNode result)
    {
        // attach documentation
        attachPreDocumentationBlocks(result, source);
        attachPostDocumentationBlocks(result, source);
    }

    private void collectComments(JSParseRootNode result)
    {
        // create a list of all comments and attach to root node

        List<Symbol> sDocComments = fScanner.getSDocComments();
        List<Symbol> vsDocComments = fScanner.getVSDocComments();
        List<Symbol> singleLineComments = fScanner.getSingleLineComments();
        List<Symbol> multiLineComments = fScanner.getMultiLineComments();

        List<JSCommentNode> comments = new ArrayList<JSCommentNode>(sDocComments.size() + vsDocComments.size()
                + singleLineComments.size() + multiLineComments.size());

        for (Symbol symbol : sDocComments)
        {
            comments.add(new JSCommentNode(IJSNodeTypes.SDOC_COMMENT, symbol.getStart(), symbol.getEnd()));
        }

        for (Symbol symbol : vsDocComments)
        {
            comments.add(new JSCommentNode(IJSNodeTypes.VSDOC_COMMENT, symbol.getStart(), symbol.getEnd()));
        }

        for (Symbol symbol : singleLineComments)
        {
            comments.add(new JSCommentNode(IJSNodeTypes.SINGLE_LINE_COMMENT, symbol.getStart(), symbol.getEnd()));
        }

        for (Symbol symbol : multiLineComments)
        {
            comments.add(new JSCommentNode(IJSNodeTypes.MULTI_LINE_COMMENT, symbol.getStart(), symbol.getEnd()));
        }

        result.setCommentNodes(comments.toArray(new IParseNode[comments.size()]));
    }

	/*
	 * (non-Javadoc)
	 * @see beaver.Parser#recoverFromError(beaver.Symbol, beaver.Parser.TokenStream)
	 */
	@Override
	protected void recoverFromError(Symbol token, TokenStream in) throws IOException, Parser.Exception
	{
		boolean success = false;

		if (this.recoveryStrategies != null)
		{
			// NOTE: Consider building a Map<Object,List<IRecoveryStrategy>> which
			// would allow us to reduce the number of recovery strategies that will
			// be attempted based on the last symbol on the stack. We may need
			// catch-all cases: 1) try these before the mapped strategies, 2)
			// try the strategies, 3) try these after the mapped strategies
			for (IRecoveryStrategy strategy : this.recoveryStrategies)
			{
				if (strategy.recover(this, getLastSymbol(), token, in, report))
				{
					success = true;
					break;
				}
			}
		}

		if (success == false)
		{
			super.recoverFromError(token, in);
		}
	}

	public JSParser() {
		super(PARSING_TABLES);


		report = new JSEvents();

		// @formatter:off
		recoveryStrategies = new ArrayList<IRecoveryStrategy>(10);

		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.SEMICOLON, ";")
		{
			public boolean recover(IParser parser, Symbol lastToken, Symbol currentToken, TokenStream in, Events report)
					throws IOException
			{
				boolean recovered = super.recover(parser, lastToken, currentToken, in, report);
				if (recovered && fSemicolonSeverity != IProblem.Severity.IGNORE)
				{
					fWorking.addError(new ParseError(IJSConstants.CONTENT_TYPE_JS, lastToken, Messages.JSParser_MissingSemicolonMsg, fSemicolonSeverity));
				}
				return recovered;
			}
		});
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.RPAREN, ")", JSTokenType.SEMICOLON, ";"));
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.IDENTIFIER, "", JSTokenType.SEMICOLON, ";", JSTokenType.DOT, JSTokenType.NEW, JSTokenType.EQUAL));
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.IDENTIFIER, "", JSTokenType.DOT, JSTokenType.NEW, JSTokenType.EQUAL));
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.IDENTIFIER, "", JSTokenType.LPAREN));
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.IDENTIFIER, "", JSTokenType.COLON, ":", JSTokenType.DOT));
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.LCURLY, "{", JSTokenType.RCURLY, "}", JSTokenType.RPAREN));
		recoveryStrategies.add(new IRecoveryStrategy()
		{
			public boolean recover(IParser parser, Symbol lastToken, Symbol currentToken, TokenStream in, Parser.Events report) throws IOException
			{
				boolean result = false;

				if (top >= 2)
				{
					Symbol symbol1 = _symbols[top - 2];
					Symbol symbol2 = _symbols[top - 1];

					if (lastToken.getId() == JSTokenType.COMMA.getIndex() && symbol2.value instanceof List<?> && symbol1.getId() == JSTokenType.LPAREN.getIndex())
					{
						Symbol term = new Symbol(JSTokenType.IDENTIFIER.getIndex(), currentToken.getStart(), currentToken.getStart() - 1, "");
						Simulator sim = new Simulator();

						in.alloc(2);
						in.insert(term, currentToken);
						in.rewind();

						if (sim.parse(in))
						{
							result = true;

							in.rewind();

							report.missingTokenInserted(term);
						}
					}
				}

				return result;
			}
		});

		JSInsertionRecoveryStrategy completeProperty = new JSInsertionRecoveryStrategy(JSTokenType.IDENTIFIER, "");
		completeProperty.addCurrentTokenTypes(JSTokenType.RCURLY);
		recoveryStrategies.add(completeProperty);

		JSInsertionRecoveryStrategy completeProperty2 = new JSInsertionRecoveryStrategy(JSTokenType.COLON, ":", JSTokenType.IDENTIFIER, "");
		completeProperty2.addCurrentTokenTypes(JSTokenType.RCURLY);
		recoveryStrategies.add(completeProperty2);
		// @formatter:on
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 4: // CoverParenthesizedExpressionAndArrowParameterList = LPAREN.l Expression.e RPAREN.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSCommaNode e = (JSCommaNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 3];
					
			return new JSGroupNode(l, e, r);
			}
			case 12: // NullLiteral = NULL.n
			{
					final Symbol n = _symbols[offset + 1];
					
			return new JSNullNode(n);
			}
			case 13: // BooleanLiteral = TRUE.t
			{
					final Symbol t = _symbols[offset + 1];
					
			return new JSTrueNode(t);
			}
			case 14: // BooleanLiteral = FALSE.f
			{
					final Symbol f = _symbols[offset + 1];
					
			return new JSFalseNode(f);
			}
			case 15: // NumericLiteral = NUMBER.n
			{
					final Symbol n = _symbols[offset + 1];
					
			return new JSNumberNode(n);
			}
			case 16: // StringLiteral = STRING.s
			{
					final Symbol s = _symbols[offset + 1];
					
			return new JSStringNode(s);
			}
			case 17: // RegularExpressionLiteral = REGEX.r
			{
					final Symbol r = _symbols[offset + 1];
					
			return new JSRegexNode(r);
			}
			case 20: // ArrayLiteral = LBRACKET.l opt$Elision.e RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSElisionNode e = (JSElisionNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 3];
					
			if (e == null) {
				return new JSArrayNode(l, r);
			}
			e.addChild(new JSNullNode());
			return new JSArrayNode(l, r, e);
			}
			case 21: // ArrayLiteral = LBRACKET.l ElementList.e RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSElementsNode e = (JSElementsNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 3];
					
			return new JSArrayNode(l, r, e);
			}
			case 22: // ArrayLiteral = LBRACKET.l ElementList.e COMMA opt$Elision.n RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSElementsNode e = (JSElementsNode) _symbol_e.value;
					final Symbol _symbol_n = _symbols[offset + 4];
					final JSElisionNode n = (JSElisionNode) _symbol_n.value;
					final Symbol r = _symbols[offset + 5];
					
			if (n == null) {
				return new JSArrayNode(l, r, e, new JSNullNode());
			}
			n.addChild(new JSNullNode());
			return new JSArrayNode(l, r, e, n);
			}
			case 23: // ElementList = opt$Elision.n SingleExpression.e
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final JSElisionNode n = (JSElisionNode) _symbol_n.value;
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			if (n == null) {
				return new JSElementsNode(e);
			}
			return new JSElementsNode(n, e);
			}
			case 25: // ElementList = ElementList.l COMMA opt$Elision.n SingleExpression.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSElementsNode l = (JSElementsNode) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 3];
					final JSElisionNode n = (JSElisionNode) _symbol_n.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final JSNode e = (JSNode) _symbol_e.value;
					
			if (n != null) {
				l.addChild(n);
			}
			l.addChild(e);

			return l;
			}
			case 27: // Elision = Elision.e COMMA
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSElisionNode e = (JSElisionNode) _symbol_e.value;
					
			e.addChild(new JSNullNode());

			return e;
			}
			case 28: // Elision = COMMA
			{
					
			return new JSElisionNode(new JSNullNode());
			}
			case 30: // ObjectLiteral = LCURLY.l RCURLY.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol r = _symbols[offset + 2];
					
			return new JSObjectNode(l, r);
			}
			case 33: // ObjectLiteral = LCURLY.l PropertyDefinitionList.p opt$COMMA RCURLY.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_p = _symbols[offset + 2];
					final ArrayList _list_p = (ArrayList) _symbol_p.value;
					final JSNode[] p = _list_p == null ? new JSNode[0] : (JSNode[]) _list_p.toArray(new JSNode[_list_p.size()]);
					final Symbol r = _symbols[offset + 4];
					
			return new JSObjectNode(l, r, p);
			}
			case 34: // PropertyDefinitionList = PropertyDefinition
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 35: // PropertyDefinitionList = PropertyDefinitionList COMMA PropertyDefinition
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 41: // LiteralPropertyName = IdentifierName.i
			{
					final Symbol i = _symbols[offset + 1];
					
			return new JSIdentifierNode(i);
			}
			case 53: // Arguments = LPAREN RPAREN
			{
					
			return new JSArgumentsNode();
			}
			case 54: // Arguments = LPAREN ArgumentList.a RPAREN
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final ArrayList _list_a = (ArrayList) _symbol_a.value;
					final JSNode[] a = _list_a == null ? new JSNode[0] : (JSNode[]) _list_a.toArray(new JSNode[_list_a.size()]);
					
			return new JSArgumentsNode(a);
			}
			case 55: // ArgumentList = ArgumentListItem
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 56: // ArgumentList = ArgumentList COMMA ArgumentListItem
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 74: // Expression = Expression.l COMMA SingleExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSCommaNode l = (JSCommaNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSCommaNode(l, r);
			}
			case 80: // SingleExpression = SingleExpression.l LBRACKET.lb Expression.r RBRACKET.rb
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol lb = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSCommaNode r = (JSCommaNode) _symbol_r.value;
					final Symbol rb = _symbols[offset + 4];
					
			return new JSGetElementNode(l, lb, r, rb);
			}
			case 85: // SingleExpression = NEW SingleExpression.e
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			// FIXME The second argument should be the Arguments node here
			return new JSConstructNode(e, new JSEmptyNode(e));
			}
			case 86: // SingleExpression = SingleExpression.l Arguments.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 2];
					final JSArgumentsNode r = (JSArgumentsNode) _symbol_r.value;
					
			return new JSInvokeNode(l, r);
			}
			case 88: // SingleExpression = SingleExpression.l DOT.o IdentifierName.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol r = _symbols[offset + 3];
					
			return new JSGetPropertyNode(l, o, new JSIdentifierNode(r));
			}
			case 89: // SingleExpression = SingleExpression.e PostUnaryOperator.o
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol o = _symbols[offset + 2];
					
			return new JSPostUnaryOperatorNode(o, e);
			}
			case 90: // SingleExpression = PreUnaryOperator.o SingleExpression.e
			{
					final Symbol o = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			return new JSPreUnaryOperatorNode(o, e);
			}
			case 91: // SingleExpression = SingleExpression.l BinaryArithmeticOperator.o SingleExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryArithmeticOperatorNode(l, o, r);
			}
			case 92: // SingleExpression = SingleExpression.l BinaryBooleanOperator.o SingleExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryBooleanOperatorNode(l, o, r);
			}
			case 93: // SingleExpression = SingleExpression.l QUESTION.q SingleExpression.t COLON.c SingleExpression.f
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol q = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final JSNode t = (JSNode) _symbol_t.value;
					final Symbol c = _symbols[offset + 4];
					final Symbol _symbol_f = _symbols[offset + 5];
					final JSNode f = (JSNode) _symbol_f.value;
					
			return new JSConditionalNode(l, q, t, c, f);
			}
			case 96: // SingleExpression = SingleExpression.l EQUAL.o SingleExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSAssignmentNode(l, o, r);
			}
			case 97: // SingleExpression = SingleExpression.l AssignmentOperator.o SingleExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSAssignmentNode(l, o, r);
			}
			case 98: // SingleExpression = THIS.t
			{
					final Symbol t = _symbols[offset + 1];
					
			return new JSThisNode(t);
			}
			case 99: // SingleExpression = Identifier.i
			{
					final Symbol i = _symbols[offset + 1];
					
			return new JSIdentifierNode(i);
			}
			case 148: // Statement = error
			{
					
			return new JSErrorNode();
			}
			case 149: // EmptyStatement = SEMICOLON.s
			{
					final Symbol s = _symbols[offset + 1];
					
			JSNode node = new JSEmptyNode(s);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 160: // Block = LCURLY opt$StatementList.a RCURLY
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final ArrayList _list_a = (ArrayList) _symbol_a.value;
					final JSNode[] a = _list_a == null ? new JSNode[0] : (JSNode[]) _list_a.toArray(new JSNode[_list_a.size()]);
					
			if (a == null) {
				return new JSStatementsNode();
			}
			return new JSStatementsNode(a);
			}
			case 161: // StatementList = StatementList StatementListItem
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 162: // StatementList = StatementListItem
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 165: // LexicalDeclaration = LetOrConst.v BindingList.l SEMICOLON
			{
					final Symbol v = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final ArrayList _list_l = (ArrayList) _symbol_l.value;
					final JSNode[] l = _list_l == null ? new JSNode[0] : (JSNode[]) _list_l.toArray(new JSNode[_list_l.size()]);
					
			JSNode node = new JSVarNode(v, l);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 168: // BindingList = BindingList COMMA LexicalBinding
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 169: // BindingList = LexicalBinding
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 174: // VariableStatement = VAR.v VariableDeclarationList.l SEMICOLON
			{
					final Symbol v = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final ArrayList _list_l = (ArrayList) _symbol_l.value;
					final JSNode[] l = _list_l == null ? new JSNode[0] : (JSNode[]) _list_l.toArray(new JSNode[_list_l.size()]);
					
			JSNode node = new JSVarNode(v, l);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 175: // VariableDeclarationList = VariableDeclarationList COMMA VariableDeclaration
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 176: // VariableDeclarationList = VariableDeclaration
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 177: // VariableDeclaration = Identifier.i opt$Initializer.z
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol z = _symbols[offset + 2];
					
			if (z == null) {
				return new JSDeclarationNode(new JSIdentifierNode(i), null, new JSEmptyNode(i));
			} else {
				return new JSDeclarationNode(new JSIdentifierNode(i), z);
			}
			}
			case 181: // ObjectBindingPattern = LCURLY.l RCURLY.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol r = _symbols[offset + 2];
					
			return new JSObjectNode(l, r);
			}
			case 182: // ObjectBindingPattern = LCURLY.l BindingPropertyList.p RCURLY.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_p = _symbols[offset + 2];
					final ArrayList _list_p = (ArrayList) _symbol_p.value;
					final JSNode[] p = _list_p == null ? new JSNode[0] : (JSNode[]) _list_p.toArray(new JSNode[_list_p.size()]);
					final Symbol r = _symbols[offset + 3];
					
			return new JSObjectNode(l, r, p);
			}
			case 183: // ObjectBindingPattern = LCURLY.l BindingPropertyList.p COMMA RCURLY.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_p = _symbols[offset + 2];
					final ArrayList _list_p = (ArrayList) _symbol_p.value;
					final JSNode[] p = _list_p == null ? new JSNode[0] : (JSNode[]) _list_p.toArray(new JSNode[_list_p.size()]);
					final Symbol r = _symbols[offset + 4];
					
			return new JSObjectNode(l, r, p);
			}
			case 186: // ArrayBindingPattern = LBRACKET.l opt$Elision.e opt$BindingRestElement.n RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSElisionNode e = (JSElisionNode) _symbol_e.value;
					final Symbol n = _symbols[offset + 3];
					final Symbol r = _symbols[offset + 4];
					
			return new JSArrayNode(l, r, e);
			}
			case 189: // BindingPropertyList = BindingPropertyList COMMA BindingProperty
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 190: // BindingPropertyList = BindingProperty
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 191: // BindingElementList = BindingElementList COMMA BindingElisionElement
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
			}
			case 192: // BindingElementList = BindingElisionElement
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
			}
			case 201: // IfStatement = IF LPAREN.l Expression.e RPAREN.r Statement.sn ELSE Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSCommaNode e = (JSCommaNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					final Symbol _symbol_sn = _symbols[offset + 5];
					final JSNode sn = (JSNode) _symbol_sn.value;
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSIfNode(l, e, r, sn, s);
			}
			case 202: // IfStatement = IF LPAREN.l Expression.e RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSCommaNode e = (JSCommaNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSIfNode(l, e, r, s, new JSEmptyNode(s));
			}
			case 203: // IterationStatement = DO Statement.s WHILE LPAREN.l Expression.e RPAREN.r SEMICOLON.s1
			{
					final Symbol _symbol_s = _symbols[offset + 2];
					final JSNode s = (JSNode) _symbol_s.value;
					final Symbol l = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final JSCommaNode e = (JSCommaNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol s1 = _symbols[offset + 7];
					
 			JSNode node = new JSDoNode(s, l, e, r);
 			node.setSemicolonIncluded(true);
 			return node;
			}
			case 204: // IterationStatement = WHILE LPAREN.l Expression.e RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSCommaNode e = (JSCommaNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSWhileNode(l, e, r, s);
			}
			case 207: // IterationStatement = FOR LPAREN.l opt$Expression.e1 SEMICOLON.s1 opt$Expression.e2 SEMICOLON.s2 opt$Expression.e3 RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e1 = _symbols[offset + 3];
					final JSCommaNode e1 = (JSCommaNode) _symbol_e1.value;
					final Symbol s1 = _symbols[offset + 4];
					final Symbol _symbol_e2 = _symbols[offset + 5];
					final JSCommaNode e2 = (JSCommaNode) _symbol_e2.value;
					final Symbol s2 = _symbols[offset + 6];
					final Symbol _symbol_e3 = _symbols[offset + 7];
					final JSCommaNode e3 = (JSCommaNode) _symbol_e3.value;
					final Symbol r = _symbols[offset + 8];
					final Symbol _symbol_s = _symbols[offset + 9];
					final JSNode s = (JSNode) _symbol_s.value;
					
			JSNode expr1 = e1;
			if (expr1 == null) {
				expr1 = new JSEmptyNode(l);
			}
			JSNode expr2 = e2;
			if (expr2 == null) {
				expr2 = new JSEmptyNode(s1);
			}
			JSNode expr3 = e3;
			if (expr3 == null) {
				expr3 = new JSEmptyNode(s2);
			}
 			return new JSForNode(l, expr1, s1, expr2, s2, expr3, r, s);
			}
			case 208: // IterationStatement = FOR LPAREN.l VAR.v VariableDeclarationList.i SEMICOLON.s1 opt$Expression.e1 SEMICOLON.s2 opt$Expression.e2 RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayList _list_i = (ArrayList) _symbol_i.value;
					final JSNode[] i = _list_i == null ? new JSNode[0] : (JSNode[]) _list_i.toArray(new JSNode[_list_i.size()]);
					final Symbol s1 = _symbols[offset + 5];
					final Symbol _symbol_e1 = _symbols[offset + 6];
					final JSCommaNode e1 = (JSCommaNode) _symbol_e1.value;
					final Symbol s2 = _symbols[offset + 7];
					final Symbol _symbol_e2 = _symbols[offset + 8];
					final JSCommaNode e2 = (JSCommaNode) _symbol_e2.value;
					final Symbol r = _symbols[offset + 9];
					final Symbol _symbol_s = _symbols[offset + 10];
					final JSNode s = (JSNode) _symbol_s.value;
					
			JSNode expr1 = e1;
			if (expr1 == null) {
				expr1 = new JSEmptyNode(s1);
			}
			JSNode expr2 = e2;
			if (expr2 == null) {
				expr2 = new JSEmptyNode(s2);
			}
 			return new JSForNode(l, new JSVarNode(v, i), s1, expr1, s2, expr2, r, s);
			}
			case 209: // IterationStatement = FOR LPAREN.l LexicalDeclaration.decl opt$Expression.e1 SEMICOLON.s1 opt$Expression.e2 RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_decl = _symbols[offset + 3];
					final JSVarNode decl = (JSVarNode) _symbol_decl.value;
					final Symbol _symbol_e1 = _symbols[offset + 4];
					final JSCommaNode e1 = (JSCommaNode) _symbol_e1.value;
					final Symbol s1 = _symbols[offset + 5];
					final Symbol _symbol_e2 = _symbols[offset + 6];
					final JSCommaNode e2 = (JSCommaNode) _symbol_e2.value;
					final Symbol r = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
			JSNode expr1 = e1;
			if (expr1 == null) {
				expr1 = new JSEmptyNode(l);
			}
			JSNode expr2 = e2;
			if (expr2 == null) {
				expr2 = new JSEmptyNode(s1);
			}
 			return new JSForNode(l, new JSVarNode(decl, expr1), s1, expr2, r, s);
			}
			case 210: // IterationStatement = FOR LPAREN.l SingleExpression.i IN.in Expression.o RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol in = _symbols[offset + 4];
					final Symbol _symbol_o = _symbols[offset + 5];
					final JSCommaNode o = (JSCommaNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForInNode(l, i, in, o, r, s);
			}
			case 211: // IterationStatement = FOR LPAREN.l VAR.v ForBinding.i IN.in Expression.o RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol v = _symbols[offset + 3];
					final Symbol i = _symbols[offset + 4];
					final Symbol in = _symbols[offset + 5];
					final Symbol _symbol_o = _symbols[offset + 6];
					final JSCommaNode o = (JSCommaNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForInNode(l, new JSVarNode(v, i), in, o, r, s);
			}
			case 212: // IterationStatement = FOR LPAREN.l ForDeclaration.decl IN.in Expression.o RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol decl = _symbols[offset + 3];
					final Symbol in = _symbols[offset + 4];
					final Symbol _symbol_o = _symbols[offset + 5];
					final JSCommaNode o = (JSCommaNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForInNode(l, decl, in, o, r, s);
			}
			case 213: // IterationStatement = FOR LPAREN.l SingleExpression.i OF.of SingleExpression.o RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol of = _symbols[offset + 4];
					final Symbol _symbol_o = _symbols[offset + 5];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForOfNode(l, i, of, o, r, s);
			}
			case 214: // IterationStatement = FOR LPAREN.l VAR.v ForBinding.i OF.of SingleExpression.o RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol v = _symbols[offset + 3];
					final Symbol i = _symbols[offset + 4];
					final Symbol of = _symbols[offset + 5];
					final Symbol _symbol_o = _symbols[offset + 6];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForOfNode(l, new JSVarNode(v, i), of, o, r, s);
			}
			case 215: // IterationStatement = FOR LPAREN.l ForDeclaration.decl OF.of SingleExpression.o RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol decl = _symbols[offset + 3];
					final Symbol of = _symbols[offset + 4];
					final Symbol _symbol_o = _symbols[offset + 5];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
 			return new JSForOfNode(l, decl, of, o, r, s);
			}
			case 219: // ContinueStatement = CONTINUE SEMICOLON
			{
					
			JSNode node = new JSContinueNode();
			node.setSemicolonIncluded(true);
			return node;
			}
			case 220: // ContinueStatement = CONTINUE Identifier.i SEMICOLON
			{
					final Symbol i = _symbols[offset + 2];
					
			JSNode node = new JSContinueNode(i);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 221: // BreakStatement = BREAK SEMICOLON
			{
					
			JSNode node = new JSBreakNode();
			node.setSemicolonIncluded(true);
			return node;
			}
			case 222: // BreakStatement = BREAK Identifier.i SEMICOLON
			{
					final Symbol i = _symbols[offset + 2];
					
			JSNode node = new JSBreakNode(i);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 223: // ReturnStatement = RETURN.r SEMICOLON
			{
					final Symbol r = _symbols[offset + 1];
					
			JSNode node = new JSReturnNode(new JSEmptyNode(r));
			node.setSemicolonIncluded(true);
			return node;
			}
			case 224: // ReturnStatement = RETURN Expression.e SEMICOLON
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSCommaNode e = (JSCommaNode) _symbol_e.value;
					
			JSNode node = new JSReturnNode(e);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 225: // WithStatement = WITH LPAREN.l Expression.e RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSCommaNode e = (JSCommaNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSWithNode(l, e, r, s);
			}
			case 226: // SwitchStatement = SWITCH LPAREN.lp Expression.e RPAREN.rp CaseBlock.children
			{
					final Symbol lp = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSCommaNode e = (JSCommaNode) _symbol_e.value;
					final Symbol rp = _symbols[offset + 4];
					final Symbol children = _symbols[offset + 5];
					
			return new JSSwitchNode(lp, e, rp, null, null, children);
			}
			case 230: // CaseBlock = LCURLY opt$CaseClauses.c1 DefaultClause.d opt$CaseClauses.c2 RCURLY
			{
					final Symbol _symbol_c1 = _symbols[offset + 2];
					final ArrayList _list_c1 = (ArrayList) _symbol_c1.value;
					final JSCaseNode[] c1 = _list_c1 == null ? new JSCaseNode[0] : (JSCaseNode[]) _list_c1.toArray(new JSCaseNode[_list_c1.size()]);
					final Symbol _symbol_d = _symbols[offset + 3];
					final JSDefaultNode d = (JSDefaultNode) _symbol_d.value;
					final Symbol _symbol_c2 = _symbols[offset + 4];
					final ArrayList _list_c2 = (ArrayList) _symbol_c2.value;
					final JSCaseNode[] c2 = _list_c2 == null ? new JSCaseNode[0] : (JSCaseNode[]) _list_c2.toArray(new JSCaseNode[_list_c2.size()]);
					
			List<JSNode> nodes = new ArrayList<JSNode>();
			if (c1 != null) {
				for (JSNode statement : c1)
				{
					nodes.add(statement);
				}
			}
			nodes.add(d);
			if (c2 != null) {
				for (JSNode statement : c2)
				{
					nodes.add(statement);
				}
			}
			JSNode[] children = nodes.toArray(new JSNode[nodes.size()]);
			return nodes;
			}
			case 231: // CaseClauses = CaseClause
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 232: // CaseClauses = CaseClauses CaseClause
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 233: // CaseClause = CASE Expression.e COLON.c opt$StatementList.s
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSCommaNode e = (JSCommaNode) _symbol_e.value;
					final Symbol c = _symbols[offset + 3];
					final Symbol _symbol_s = _symbols[offset + 4];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final JSNode[] s = _list_s == null ? new JSNode[0] : (JSNode[]) _list_s.toArray(new JSNode[_list_s.size()]);
					
			if (s == null) {
				return new JSCaseNode(e, c);
			}
			return new JSCaseNode(e, c, s);
			}
			case 234: // DefaultClause = DEFAULT COLON.c opt$StatementList.s
			{
					final Symbol c = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final JSNode[] s = _list_s == null ? new JSNode[0] : (JSNode[]) _list_s.toArray(new JSNode[_list_s.size()]);
					
			if (s == null) {
				return new JSDefaultNode(c);
			}
			return new JSDefaultNode(c, s);
			}
			case 235: // LabelledStatement = Identifier.i COLON.c LabelledItem.s
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol c = _symbols[offset + 2];
					final Symbol s = _symbols[offset + 3];
					
			JSNode id = new JSIdentifierNode(i);
			id.setLocation(i.getStart(), i.getEnd());

			return new JSLabelledNode(id, c, s);
			}
			case 238: // ThrowStatement = THROW Expression.e SEMICOLON
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSCommaNode e = (JSCommaNode) _symbol_e.value;
					
			JSNode node = new JSThrowNode(e);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 239: // TryStatement = TRY Block.b Catch.c
			{
					final Symbol b = _symbols[offset + 2];
					final Symbol _symbol_c = _symbols[offset + 3];
					final JSCatchNode c = (JSCatchNode) _symbol_c.value;
					
			return new JSTryNode(b, c, new JSEmptyNode(c));
			}
			case 240: // TryStatement = TRY Block.b Finally.f
			{
					final Symbol b = _symbols[offset + 2];
					final Symbol _symbol_f = _symbols[offset + 3];
					final JSFinallyNode f = (JSFinallyNode) _symbol_f.value;
					
			return new JSTryNode(b, new JSEmptyNode(b), f);
			}
			case 241: // TryStatement = TRY Block.b Catch.c Finally.f
			{
					final Symbol b = _symbols[offset + 2];
					final Symbol _symbol_c = _symbols[offset + 3];
					final JSCatchNode c = (JSCatchNode) _symbol_c.value;
					final Symbol _symbol_f = _symbols[offset + 4];
					final JSFinallyNode f = (JSFinallyNode) _symbol_f.value;
					
			return new JSTryNode(b, c, f);
			}
			case 242: // Catch = CATCH LPAREN CatchParameter.p RPAREN Block.b
			{
					final Symbol p = _symbols[offset + 3];
					final Symbol b = _symbols[offset + 5];
					
			return new JSCatchNode(p, b);
			}
			case 243: // Finally = FINALLY Block.b
			{
					final Symbol b = _symbols[offset + 2];
					
			return new JSFinallyNode(b);
			}
			case 247: // FunctionDeclaration = FUNCTION Identifier.ident LPAREN FormalParameters.params RPAREN LCURLY FunctionBody.body RCURLY
			{
					final Symbol ident = _symbols[offset + 2];
					final Symbol params = _symbols[offset + 4];
					final Symbol _symbol_body = _symbols[offset + 7];
					final ArrayList _list_body = (ArrayList) _symbol_body.value;
					final JSNode[] body = _list_body == null ? new JSNode[0] : (JSNode[]) _list_body.toArray(new JSNode[_list_body.size()]);
					
			return new JSFunctionNode(
				new JSIdentifierNode(ident),
				params,
				body
			);
			}
			case 250: // FunctionExpression = FUNCTION.f opt$Identifier.ident LPAREN FormalParameters.params RPAREN LCURLY FunctionBody.body RCURLY
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol ident = _symbols[offset + 2];
					final Symbol params = _symbols[offset + 4];
					final Symbol _symbol_body = _symbols[offset + 7];
					final ArrayList _list_body = (ArrayList) _symbol_body.value;
					final JSNode[] body = _list_body == null ? new JSNode[0] : (JSNode[]) _list_body.toArray(new JSNode[_list_body.size()]);
					
			if (ident != null) {
				return new JSFunctionNode(
					new JSIdentifierNode(ident),
					params,
					body
				);
			}
			return new JSFunctionNode(
				new JSEmptyNode(f),
				params,
				body
			);
			}
			case 253: // FormalParameters = 
			{
					
			return new JSParametersNode();
			}
			case 257: // FormalsList = FormalsList COMMA FormalParameter
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
			}
			case 258: // FormalsList = FormalParameter
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
			}
			case 269: // MethodDefinition = GET PropertyName.n LPAREN RPAREN LCURLY FunctionBody.body RCURLY
			{
					final Symbol n = _symbols[offset + 2];
					final Symbol _symbol_body = _symbols[offset + 6];
					final ArrayList _list_body = (ArrayList) _symbol_body.value;
					final JSNode[] body = _list_body == null ? new JSNode[0] : (JSNode[]) _list_body.toArray(new JSNode[_list_body.size()]);
					
			return new JSNameValuePairNode(n, body);
			}
			case 270: // MethodDefinition = SET PropertyName.n LPAREN PropertySetParameterList.p RPAREN LCURLY FunctionBody.body RCURLY
			{
					final Symbol n = _symbols[offset + 2];
					final Symbol p = _symbols[offset + 4];
					final Symbol _symbol_body = _symbols[offset + 7];
					final ArrayList _list_body = (ArrayList) _symbol_body.value;
					final JSNode[] body = _list_body == null ? new JSNode[0] : (JSNode[]) _list_body.toArray(new JSNode[_list_body.size()]);
					
			JSIdentifierNode ident = new JSIdentifierNode(p);
			JSParametersNode params = new JSParametersNode(ident);
			params.setLocation(ident.getStartingOffset(), ident.getEndingOffset());
			return new JSNameValuePairNode(n, params, body);
			}
			case 287: // ClassElementList = ClassElement
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
			}
			case 288: // ClassElementList = ClassElementList ClassElement
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
			}
			case 294: // Script = opt$ScriptBody.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final JSNode[] s = _list_s == null ? new JSNode[0] : (JSNode[]) _list_s.toArray(new JSNode[_list_s.size()]);
					
			return new JSParseRootNode(s);
			}
			case 298: // Module = opt$ModuleBody.m
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final ArrayList _list_m = (ArrayList) _symbol_m.value;
					final JSNode[] m = _list_m == null ? new JSNode[0] : (JSNode[]) _list_m.toArray(new JSNode[_list_m.size()]);
					
			return new JSParseRootNode(m);
			}
			case 300: // ModuleItemList = ModuleItemList ModuleItem
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 301: // ModuleItemList = ModuleItem
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 318: // ImportsList = ImportsList COMMA ImportSpecifier
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
			}
			case 319: // ImportsList = ImportSpecifier
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
			}
			case 335: // ExportsList = ExportsList COMMA ExportSpecifier
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
			}
			case 336: // ExportsList = ExportSpecifier
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
			}
			case 18: // opt$Elision = 
			case 31: // opt$COMMA = 
			case 158: // opt$StatementList = 
			case 170: // opt$Initializer = 
			case 184: // opt$BindingRestElement = 
			case 205: // opt$Expression = 
			case 227: // opt$CaseClauses = 
			case 248: // opt$Identifier = 
			case 292: // opt$ScriptBody = 
			case 296: // opt$ModuleBody = 
			{
				return new Symbol(null);
			}
			case 0: // $goal = Module
			case 2: // Identifier = IDENTIFIER
			case 3: // IdentifierName = Identifier
			case 8: // Literal = NullLiteral
			case 9: // Literal = BooleanLiteral
			case 10: // Literal = NumericLiteral
			case 11: // Literal = StringLiteral
			case 19: // opt$Elision = Elision
			case 32: // opt$COMMA = COMMA
			case 36: // PropertyDefinition = CoverInitializedName
			case 38: // PropertyDefinition = MethodDefinition
			case 39: // PropertyName = LiteralPropertyName
			case 40: // PropertyName = ComputedPropertyName
			case 42: // LiteralPropertyName = StringLiteral
			case 43: // LiteralPropertyName = NumericLiteral
			case 47: // TemplateLiteral = NoSubstitutionTemplate
			case 49: // TemplateSpans = TemplateTail
			case 57: // ArgumentListItem = SingleExpression
			case 59: // MultiplicativeOperator = STAR
			case 60: // MultiplicativeOperator = FORWARD_SLASH
			case 61: // MultiplicativeOperator = PERCENT
			case 62: // AssignmentOperator = STAR_EQUAL
			case 63: // AssignmentOperator = FORWARD_SLASH_EQUAL
			case 64: // AssignmentOperator = PERCENT_EQUAL
			case 65: // AssignmentOperator = PLUS_EQUAL
			case 66: // AssignmentOperator = MINUS_EQUAL
			case 67: // AssignmentOperator = LESS_LESS_EQUAL
			case 68: // AssignmentOperator = GREATER_GREATER_EQUAL
			case 69: // AssignmentOperator = GREATER_GREATER_GREATER_EQUAL
			case 70: // AssignmentOperator = AMPERSAND_EQUAL
			case 71: // AssignmentOperator = CARET_EQUAL
			case 72: // AssignmentOperator = PIPE_EQUAL
			case 73: // Expression = SingleExpression
			case 75: // SingleExpression = FunctionExpression
			case 76: // SingleExpression = GeneratorExpression
			case 77: // SingleExpression = RegularExpressionLiteral
			case 78: // SingleExpression = TemplateLiteral
			case 79: // SingleExpression = CoverParenthesizedExpressionAndArrowParameterList
			case 81: // SingleExpression = SingleExpression.l TemplateLiteral
			case 94: // SingleExpression = YieldExpression
			case 95: // SingleExpression = ArrowFunction
			case 100: // SingleExpression = Literal
			case 101: // SingleExpression = ArrayLiteral
			case 102: // SingleExpression = ObjectLiteral
			case 103: // PostUnaryOperator = PLUS_PLUS
			case 104: // PostUnaryOperator = MINUS_MINUS
			case 105: // PreUnaryOperator = PostUnaryOperator
			case 106: // PreUnaryOperator = DELETE
			case 107: // PreUnaryOperator = VOID
			case 108: // PreUnaryOperator = TYPEOF
			case 109: // PreUnaryOperator = PLUS
			case 110: // PreUnaryOperator = MINUS
			case 111: // PreUnaryOperator = TILDE
			case 112: // PreUnaryOperator = EXCLAMATION
			case 113: // BinaryArithmeticOperator = MultiplicativeOperator
			case 114: // BinaryArithmeticOperator = PIPE
			case 115: // BinaryArithmeticOperator = CARET
			case 116: // BinaryArithmeticOperator = AMPERSAND
			case 117: // BinaryArithmeticOperator = PLUS
			case 118: // BinaryArithmeticOperator = MINUS
			case 119: // BinaryArithmeticOperator = LESS_LESS
			case 120: // BinaryArithmeticOperator = GREATER_GREATER
			case 121: // BinaryArithmeticOperator = GREATER_GREATER_GREATER
			case 122: // BinaryBooleanOperator = PIPE_PIPE
			case 123: // BinaryBooleanOperator = AMPERSAND_AMPERSAND
			case 124: // BinaryBooleanOperator = EXCLAMATION_EQUAL_EQUAL
			case 125: // BinaryBooleanOperator = EQUAL_EQUAL_EQUAL
			case 126: // BinaryBooleanOperator = EXCLAMATION_EQUAL
			case 127: // BinaryBooleanOperator = EQUAL_EQUAL
			case 128: // BinaryBooleanOperator = IN
			case 129: // BinaryBooleanOperator = INSTANCEOF
			case 130: // BinaryBooleanOperator = LESS
			case 131: // BinaryBooleanOperator = GREATER
			case 132: // BinaryBooleanOperator = LESS_EQUAL
			case 133: // BinaryBooleanOperator = GREATER_EQUAL
			case 134: // Statement = BlockStatement
			case 135: // Statement = VariableStatement
			case 136: // Statement = EmptyStatement
			case 137: // Statement = ExpressionStatement
			case 138: // Statement = IfStatement
			case 139: // Statement = BreakableStatement
			case 140: // Statement = ContinueStatement
			case 141: // Statement = BreakStatement
			case 142: // Statement = ReturnStatement
			case 143: // Statement = WithStatement
			case 144: // Statement = LabelledStatement
			case 145: // Statement = ThrowStatement
			case 146: // Statement = TryStatement
			case 147: // Statement = DebuggerStatement
			case 150: // Declaration = HoistableDeclaration
			case 151: // Declaration = ClassDeclaration
			case 152: // Declaration = LexicalDeclaration
			case 153: // HoistableDeclaration = FunctionDeclaration
			case 154: // HoistableDeclaration = GeneratorDeclaration
			case 155: // BreakableStatement = IterationStatement
			case 156: // BreakableStatement = SwitchStatement
			case 157: // BlockStatement = Block
			case 159: // opt$StatementList = StatementList
			case 163: // StatementListItem = Statement
			case 164: // StatementListItem = Declaration
			case 166: // LetOrConst = LET
			case 167: // LetOrConst = CONST
			case 171: // opt$Initializer = Initializer
			case 179: // BindingPattern = ObjectBindingPattern
			case 180: // BindingPattern = ArrayBindingPattern
			case 185: // opt$BindingRestElement = BindingRestElement
			case 194: // BindingProperty = SingleNameBinding
			case 196: // BindingElement = SingleNameBinding
			case 206: // opt$Expression = Expression
			case 217: // ForBinding = Identifier
			case 218: // ForBinding = BindingPattern
			case 228: // opt$CaseClauses = CaseClauses
			case 236: // LabelledItem = Statement
			case 237: // LabelledItem = FunctionDeclaration
			case 244: // CatchParameter = Identifier
			case 245: // CatchParameter = BindingPattern
			case 249: // opt$Identifier = Identifier
			case 251: // StrictFormalParameters = FormalParameters
			case 252: // FormalParameters = FormalParameterList.params
			case 254: // FormalParameterList = FunctionRestParameter
			case 255: // FormalParameterList = FormalsList
			case 259: // FunctionRestParameter = BindingRestElement
			case 260: // FormalParameter = BindingElement
			case 261: // FunctionBody = FunctionStatementList
			case 262: // FunctionStatementList = opt$StatementList
			case 264: // ArrowParameters = Identifier
			case 265: // ArrowParameters = CoverParenthesizedExpressionAndArrowParameterList
			case 266: // ConciseBody = SingleExpression
			case 268: // MethodDefinition = GeneratorMethod
			case 271: // PropertySetParameterList = FormalParameter
			case 275: // GeneratorBody = FunctionBody
			case 276: // YieldExpression = YIELD
			case 286: // ClassBody = ClassElementList
			case 289: // ClassElement = MethodDefinition
			case 291: // ClassElement = SEMICOLON
			case 293: // opt$ScriptBody = ScriptBody
			case 295: // ScriptBody = StatementList
			case 297: // opt$ModuleBody = ModuleBody
			case 299: // ModuleBody = ModuleItemList
			case 302: // ModuleItem = ImportDeclaration
			case 303: // ModuleItem = ExportDeclaration
			case 304: // ModuleItem = StatementListItem
			case 307: // ImportClause = ImportedDefaultBinding
			case 308: // ImportClause = NameSpaceImport
			case 309: // ImportClause = NamedImports
			case 312: // ImportedDefaultBinding = ImportedBinding
			case 321: // ImportSpecifier = ImportedBinding
			case 322: // ModuleSpecifier = STRING
			case 323: // ImportedBinding = Identifier
			case 338: // ExportSpecifier = IdentifierName
			case 339: // NoSubstitutionTemplate = NO_SUB_TEMPLATE
			case 340: // TemplateHead = TEMPLATE_HEAD
			case 341: // TemplateMiddle = TEMPLATE_MIDDLE
			case 342: // TemplateTail = TEMPLATE_TAIL
			{
				return _symbols[offset + 1];
			}
			case 1: // $goal = $Script Script
			case 5: // CoverParenthesizedExpressionAndArrowParameterList = LPAREN RPAREN
			case 24: // ElementList = opt$Elision.n SpreadElement.e
			case 29: // SpreadElement = DOT_DOT_DOT SingleExpression
			case 45: // CoverInitializedName = Identifier Initializer
			case 46: // Initializer = EQUAL SingleExpression
			case 50: // TemplateSpans = TemplateMiddleList TemplateTail
			case 51: // TemplateMiddleList = TemplateMiddle Expression
			case 58: // ArgumentListItem = DOT_DOT_DOT SingleExpression
			case 87: // SingleExpression = SUPER Arguments
			case 172: // LexicalBinding = Identifier opt$Initializer
			case 173: // LexicalBinding = BindingPattern Initializer
			case 178: // VariableDeclaration = BindingPattern Initializer
			case 193: // BindingElisionElement = opt$Elision BindingElement
			case 197: // BindingElement = BindingPattern opt$Initializer
			case 198: // SingleNameBinding = Identifier opt$Initializer
			case 199: // BindingRestElement = DOT_DOT_DOT Identifier
			case 200: // ExpressionStatement = Expression SEMICOLON
			case 216: // ForDeclaration = LetOrConst ForBinding
			case 229: // CaseBlock = LCURLY opt$CaseClauses.c RCURLY
			case 246: // DebuggerStatement = DEBUGGER SEMICOLON
			case 267: // ConciseBody = LCURLY FunctionBody.body RCURLY
			case 277: // YieldExpression = YIELD SingleExpression
			case 284: // ClassTail = LCURLY RCURLY
			case 285: // ClassHeritage = EXTENDS SingleExpression
			case 290: // ClassElement = STATIC MethodDefinition
			case 314: // NamedImports = LCURLY RCURLY
			case 317: // FromClause = FROM ModuleSpecifier
			case 327: // ExportDeclaration = EXPORT VariableStatement
			case 328: // ExportDeclaration = EXPORT Declaration
			case 332: // ExportClause = LCURLY RCURLY
			{
				return _symbols[offset + 2];
			}
			case 37: // PropertyDefinition = PropertyName COLON SingleExpression
			case 44: // ComputedPropertyName = LBRACKET SingleExpression RBRACKET
			case 48: // TemplateLiteral = TemplateHead Expression TemplateSpans
			case 52: // TemplateMiddleList = TemplateMiddleList TemplateMiddle Expression
			case 83: // SingleExpression = SUPER DOT IdentifierName
			case 84: // SingleExpression = NEW DOT TARGET
			case 187: // ArrayBindingPattern = LBRACKET.l BindingElementList.n RBRACKET.r
			case 195: // BindingProperty = PropertyName COLON BindingElement
			case 256: // FormalParameterList = FormalsList COMMA FunctionRestParameter
			case 263: // ArrowFunction = ArrowParameters ARROW ConciseBody
			case 278: // YieldExpression = YIELD STAR SingleExpression
			case 279: // ClassDeclaration = CLASS Identifier ClassTail
			case 280: // ClassExpression = CLASS opt$Identifier ClassTail
			case 282: // ClassTail = LCURLY ClassBody RCURLY
			case 283: // ClassTail = ClassHeritage LCURLY RCURLY
			case 306: // ImportDeclaration = IMPORT ModuleSpecifier SEMICOLON
			case 310: // ImportClause = ImportedDefaultBinding COMMA NameSpaceImport
			case 311: // ImportClause = ImportedDefaultBinding COMMA NamedImports
			case 313: // NameSpaceImport = STAR AS ImportedBinding
			case 315: // NamedImports = LCURLY ImportsList RCURLY
			case 320: // ImportSpecifier = IdentifierName AS ImportedBinding
			case 326: // ExportDeclaration = EXPORT ExportClause SEMICOLON
			case 329: // ExportDeclaration = EXPORT DEFAULT HoistableDeclaration
			case 330: // ExportDeclaration = EXPORT DEFAULT ClassExpression
			case 333: // ExportClause = LCURLY ExportsList RCURLY
			case 337: // ExportSpecifier = IdentifierName AS IdentifierName
			{
				return _symbols[offset + 3];
			}
			case 6: // CoverParenthesizedExpressionAndArrowParameterList = LPAREN DOT_DOT_DOT Identifier RPAREN
			case 26: // ElementList = ElementList.l COMMA opt$Elision.n SpreadElement.e
			case 82: // SingleExpression = SUPER LBRACKET Expression RBRACKET
			case 281: // ClassTail = ClassHeritage LCURLY ClassBody RCURLY
			case 305: // ImportDeclaration = IMPORT ImportClause FromClause SEMICOLON
			case 316: // NamedImports = LCURLY ImportsList COMMA RCURLY
			case 324: // ExportDeclaration = EXPORT STAR FromClause SEMICOLON
			case 325: // ExportDeclaration = EXPORT ExportClause FromClause SEMICOLON
			case 334: // ExportClause = LCURLY ExportsList COMMA RCURLY
			{
				return _symbols[offset + 4];
			}
			case 331: // ExportDeclaration = EXPORT DEFAULT Identifier SingleExpression SEMICOLON
			{
				return _symbols[offset + 5];
			}
			case 7: // CoverParenthesizedExpressionAndArrowParameterList = LPAREN Expression COMMA DOT_DOT_DOT Identifier RPAREN
			case 188: // ArrayBindingPattern = LBRACKET.l BindingElementList.n COMMA opt$Elision.e opt$BindingRestElement.z RBRACKET.r
			{
				return _symbols[offset + 6];
			}
			case 272: // GeneratorMethod = STAR PropertyName LPAREN StrictFormalParameters RPAREN LCURLY GeneratorBody RCURLY
			{
				return _symbols[offset + 8];
			}
			case 273: // GeneratorDeclaration = FUNCTION STAR Identifier LPAREN FormalParameters RPAREN LCURLY GeneratorBody RCURLY
			case 274: // GeneratorExpression = FUNCTION STAR opt$Identifier LPAREN FormalParameters RPAREN LCURLY GeneratorBody RCURLY
			{
				return _symbols[offset + 9];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
